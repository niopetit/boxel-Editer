# シェーダー仕様書

## 1. 概要

Boxel Editorは GLSLを用いたカスタムシェーダーで、ボクセルメッシュの表示と頂点ハイライト機能を実装する。このドキュメントはシェーダーの仕様と実装方法を定義する。

## 2. シェーダー構成

### 2.1 使用するシェーダーペア

Boxel Editorは以下の複数のシェーダーペアを使用：

1. **ボクセルメッシュシェーダー**（ボクセルの面表示）
   - 頂点シェーダー: `voxel.vert`
   - フラグメントシェーダー: `voxel.frag`

2. **頂点ハイライトシェーダー**（頂点表示）
   - 頂点シェーダー: `vertex_highlight.vert`
   - フラグメントシェーダー: `vertex_highlight.frag`

3. **選択ハイライトシェーダー**（選択状態表示）
   - 頂点シェーダー: `selection.vert`
   - フラグメントシェーダー: `selection.frag`

4. **隣接オブジェクト用シェーダー**（グレースケール表示）
   - 頂点シェーダー: `adjacent.vert`
   - フラグメントシェーダー: `adjacent.frag`

## 3. ボクセルメッシュシェーダー

### 3.1 頂点シェーダー（voxel.vert）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 aPosition;        // 頂点座標
in vec3 aNormal;          // 法線ベクトル
in vec3 aColor;           // 頂点カラー（面着色情報）

// uniform
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

// 出力
out vec3 vPosition;       // ワールド座標
out vec3 vNormal;         // ワールド法線
out vec3 vColor;          // カラー情報

void main() {
  // ワールド座標を計算
  vPosition = vec3(uModelMatrix * vec4(aPosition, 1.0));
  
  // ワールド法線を計算
  vNormal = normalize(uNormalMatrix * aNormal);
  
  // カラー情報を転送
  vColor = aColor;
  
  // クリップ空間の座標を計算
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(vPosition, 1.0);
}
```

### 3.2 フラグメントシェーダー（voxel.frag）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 vPosition;
in vec3 vNormal;
in vec3 vColor;

// uniform
uniform vec3 uCameraPosition;
uniform vec3 uLightPosition;      // ライト位置
uniform vec3 uLightColor;         // ライトカラー（デフォルト: 白色）
uniform float uAmbientIntensity;  // アンビエント強度（デフォルト: 0.5）

// 出力
out vec4 outColor;

void main() {
  // ライト方向
  vec3 lightDir = normalize(uLightPosition - vPosition);
  
  // ビュー方向
  vec3 viewDir = normalize(uCameraPosition - vPosition);
  
  // アンビエント光
  vec3 ambient = vColor * uAmbientIntensity;
  
  // ディフューズ光
  float diffuse = max(dot(vNormal, lightDir), 0.0);
  vec3 diffuseColor = vColor * diffuse * uLightColor;
  
  // スペキュラー光（ボクセルは通常スペキュラーは弱い）
  vec3 reflectDir = reflect(-lightDir, vNormal);
  float specular = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);
  vec3 specularColor = uLightColor * specular * 0.3;
  
  // 最終色
  vec3 finalColor = ambient + diffuseColor + specularColor;
  
  outColor = vec4(finalColor, 1.0);
}
```

## 4. 頂点ハイライトシェーダー

### 4.1 概要

頂点をスフィア（球体）として描画し、選択状態や常時表示の青色ハイライトを実現する。

### 4.2 頂点シェーダー（vertex_highlight.vert）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 aPosition;                // 頂点座標
in vec3 aOffset;                  // スフィアメッシュのオフセット

// uniform
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform float uVertexSize;        // 頂点スフィアのサイズ（デフォルト: 0.5）
uniform float uHighlightSize;     // ハイライト時のサイズ（デフォルト: 0.8）
uniform bool uIsSelected;         // 選択状態フラグ

// 出力
out float vAlpha;                 // 不透明度

void main() {
  // スフィアのサイズを決定
  float size = uIsSelected ? uHighlightSize : uVertexSize;
  
  // スフィアのメッシュをスケール
  vec3 scaledOffset = aOffset * size;
  
  // 最終頂点座標
  vec3 worldPosition = vec3(uModelMatrix * vec4(aPosition, 1.0)) + scaledOffset;
  
  // アルファ値（選択時は不透明度を上げる）
  vAlpha = uIsSelected ? 1.0 : 0.7;
  
  // クリップ空間の座標
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(worldPosition, 1.0);
}
```

### 4.3 フラグメントシェーダー（vertex_highlight.frag）

```glsl
#version 300 es
precision highp float;

// 入力
in float vAlpha;

// uniform
uniform vec3 uVertexColor;        // 頂点カラー（デフォルト: #4A90E2 青色）
uniform float uGlow;              // グロウ強度（デフォルト: 0.2）

// 出力
out vec4 outColor;

void main() {
  // スフィアの表面を滑らかに描画するため、gl_PointCoord を使用
  // （ただし、メッシュベースの場合は標準の法線ベースシェーディングを使用）
  
  // 頂点カラーにグロウ効果を追加
  vec3 glowColor = uVertexColor * (1.0 + uGlow);
  
  outColor = vec4(glowColor, vAlpha);
}
```

## 5. 選択ハイライトシェーダー

### 5.1 概要

ボクセルの選択状態を表示するためのシェーダー。選択された面の周辺をハイライトする。

### 5.2 頂点シェーダー（selection.vert）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 aPosition;
in vec3 aNormal;

// uniform
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;
uniform float uOutlineWidth;      // アウトラインの幅（デフォルト: 0.05）
uniform bool uIsSelected;         // 選択状態フラグ

// 出力
out vec3 vNormal;

void main() {
  vec3 worldPosition = vec3(uModelMatrix * vec4(aPosition, 1.0));
  vNormal = normalize(uNormalMatrix * aNormal);
  
  // 選択状態の場合、法線方向に頂点を押し出す
  if (uIsSelected) {
    worldPosition += vNormal * uOutlineWidth;
  }
  
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(worldPosition, 1.0);
}
```

### 5.3 フラグメントシェーダー（selection.frag）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 vNormal;

// uniform
uniform vec3 uSelectionColor;     // 選択色（デフォルト: #FFFF00 黄色）
uniform float uSelectionIntensity; // 選択強度（デフォルト: 0.8）

// 出力
out vec4 outColor;

void main() {
  // 選択色を出力
  outColor = vec4(uSelectionColor, uSelectionIntensity);
}
```

## 6. 隣接オブジェクト用シェーダー

### 6.1 概要

隣接オブジェクトをグレースケール表示する。元の着色情報を無視し、灰色で統一された表示を行う。

### 6.2 頂点シェーダー（adjacent.vert）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 aPosition;
in vec3 aNormal;

// uniform
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

// 出力
out vec3 vPosition;
out vec3 vNormal;

void main() {
  vPosition = vec3(uModelMatrix * vec4(aPosition, 1.0));
  vNormal = normalize(uNormalMatrix * aNormal);
  
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(vPosition, 1.0);
}
```

### 6.3 フラグメントシェーダー（adjacent.frag）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 vPosition;
in vec3 vNormal;

// uniform
uniform vec3 uCameraPosition;
uniform vec3 uLightPosition;
uniform float uAdjacentAlpha;     // 隣接オブジェクトのアルファ値（デフォルト: 0.75）

// 出力
out vec4 outColor;

void main() {
  // グレースケール色（固定値）
  vec3 baseColor = vec3(0.533, 0.533, 0.533); // #888888
  
  // ライト計算（アンビエント + ディフューズ）
  vec3 lightDir = normalize(uLightPosition - vPosition);
  float diffuse = max(dot(vNormal, lightDir), 0.0);
  
  vec3 finalColor = baseColor * (0.5 + 0.5 * diffuse);
  
  outColor = vec4(finalColor, uAdjacentAlpha);
}
```

## 7. uniform 変数の管理

### 7.1 共通 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uModelMatrix | mat4 | 単位行列 | モデル変換行列 |
| uViewMatrix | mat4 | 単位行列 | ビュー変換行列 |
| uProjectionMatrix | mat4 | 単位行列 | プロジェクション行列 |
| uNormalMatrix | mat3 | 単位行列 | 法線変換行列 |
| uCameraPosition | vec3 | (0, 0, 0) | カメラの位置 |

### 7.2 ライト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uLightPosition | vec3 | (50, 50, 50) | ライトの位置 |
| uLightColor | vec3 | (1, 1, 1) | ライトの色（白色） |
| uAmbientIntensity | float | 0.5 | アンビエント光の強度 |

### 7.3 頂点ハイライト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uVertexSize | float | 0.5 | 頂点スフィアのサイズ |
| uHighlightSize | float | 0.8 | 選択時の頂点スフィアのサイズ |
| uVertexColor | vec3 | (0.29, 0.56, 0.89) | 頂点カラー（#4A90E2） |
| uGlow | float | 0.2 | グロウ効果の強度 |
| uIsSelected | bool | false | 頂点が選択されているかどうか |

### 7.4 選択ハイライト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uSelectionColor | vec3 | (1, 1, 0) | 選択色（黄色） |
| uSelectionIntensity | float | 0.8 | 選択ハイライトの不透明度 |
| uOutlineWidth | float | 0.05 | アウトラインの幅 |

### 7.5 隣接オブジェクト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uAdjacentAlpha | float | 0.75 | 隣接オブジェクトのアルファ値 |

## 8. シェーダープログラム管理

### 8.1 シェーダーコンパイル

```typescript
function compileShader(
  gl: WebGL2RenderingContext,
  source: string,
  type: number
): WebGLShader {
  const shader = gl.createShader(type)!;
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(
      "シェーダーのコンパイル失敗:",
      gl.getShaderInfoLog(shader)
    );
    gl.deleteShader(shader);
    throw new Error("シェーダーのコンパイルに失敗しました");
  }
  
  return shader;
}
```

### 8.2 シェーダープログラムリンク

```typescript
function linkProgram(
  gl: WebGL2RenderingContext,
  vertexShader: WebGLShader,
  fragmentShader: WebGLShader
): WebGLProgram {
  const program = gl.createProgram()!;
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(
      "シェーダープログラムのリンク失敗:",
      gl.getProgramInfoLog(program)
    );
    gl.deleteProgram(program);
    throw new Error("シェーダープログラムのリンクに失敗しました");
  }
  
  return program;
}
```

### 8.3 uniform 変数の設定

```typescript
function setUniforms(
  gl: WebGL2RenderingContext,
  program: WebGLProgram,
  uniforms: { [key: string]: any }
): void {
  gl.useProgram(program);
  
  for (const [name, value] of Object.entries(uniforms)) {
    const location = gl.getUniformLocation(program, name);
    if (!location) continue;
    
    if (typeof value === "number") {
      gl.uniform1f(location, value);
    } else if (Array.isArray(value)) {
      if (value.length === 2) {
        gl.uniform2fv(location, value);
      } else if (value.length === 3) {
        gl.uniform3fv(location, value);
      } else if (value.length === 4) {
        gl.uniform4fv(location, value);
      } else if (value.length === 9) {
        gl.uniformMatrix3fv(location, false, value);
      } else if (value.length === 16) {
        gl.uniformMatrix4fv(location, false, value);
      }
    } else if (typeof value === "boolean") {
      gl.uniform1i(location, value ? 1 : 0);
    }
  }
}
```

## 9. 描画パイプライン

### 9.1 レンダリング順序

```
1. メインオブジェクトのボクセルメッシュを描画
   - シェーダー: voxel.vert / voxel.frag
   - ブレンドモード: Opaque
   
2. 隣接オブジェクトのメッシュを描画
   - シェーダー: adjacent.vert / adjacent.frag
   - ブレンドモード: Blend（Alpha）
   
3. 頂点ハイライトを描画（メインオブジェクト）
   - シェーダー: vertex_highlight.vert / vertex_highlight.frag
   - ブレンドモード: Additive
   - デプステスト: 常に描画（gl.disable(gl.DEPTH_TEST)）
   
4. 選択ハイライトを描画
   - シェーダー: selection.vert / selection.frag
   - ブレンドモード: Blend（Alpha）
```

### 9.2 実装例

```typescript
function render(): void {
  gl.clearColor(0.2, 0.2, 0.2, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  // 1. メインオブジェクト描画
  gl.useProgram(voxelProgram);
  setUniforms(gl, voxelProgram, {
    uModelMatrix: mainObject.matrix,
    uViewMatrix: camera.viewMatrix,
    uProjectionMatrix: camera.projectionMatrix,
    uLightPosition: lightPosition
  });
  gl.drawElements(gl.TRIANGLES, mainObject.indexCount, gl.UNSIGNED_INT, 0);
  
  // 2. 隣接オブジェクト描画
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  for (const adjacent of adjacentObjects) {
    gl.useProgram(adjacentProgram);
    setUniforms(gl, adjacentProgram, {
      uModelMatrix: adjacent.matrix,
      uViewMatrix: camera.viewMatrix,
      uProjectionMatrix: camera.projectionMatrix,
      uAdjacentAlpha: 0.75
    });
    gl.drawElements(gl.TRIANGLES, adjacent.indexCount, gl.UNSIGNED_INT, 0);
  }
  
  // 3. 頂点ハイライト描画
  gl.disable(gl.DEPTH_TEST);
  gl.blendFunc(gl.ONE, gl.ONE); // Additive blend
  gl.useProgram(vertexHighlightProgram);
  setUniforms(gl, vertexHighlightProgram, {
    uVertexColor: [0.29, 0.56, 0.89],
    uVertexSize: 0.5
  });
  gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
  gl.enable(gl.DEPTH_TEST);
  
  // 4. 選択ハイライト描画
  if (selectedFace) {
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(selectionProgram);
    setUniforms(gl, selectionProgram, {
      uSelectionColor: [1, 1, 0],
      uOutlineWidth: 0.05
    });
    gl.drawElements(gl.TRIANGLES, selectedFace.indexCount, gl.UNSIGNED_INT, 0);
  }
}
```

## 10. パフォーマンス最適化

### 10.1 シェーダーの最適化

- **uniform の事前計算**: 毎フレーム計算する必要のない値はアプリケーション側で事前計算
- **精度の調整**: 必要に応じて `lowp` / `mediump` を使用（モバイル対応）
- **演算量削減**: 複雑な計算（例: 正規化）は可能な限り頂点シェーダーで実行

### 10.2 バッチ処理

```typescript
// 同一シェーダー＆同一マテリアルの描画をまとめる
function renderBatch(
  meshes: Mesh[],
  program: WebGLProgram
): void {
  gl.useProgram(program);
  
  for (const mesh of meshes) {
    gl.bindVertexArray(mesh.vao);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(program, "uModelMatrix"),
      false,
      mesh.matrix
    );
    gl.drawElements(gl.TRIANGLES, mesh.indexCount, gl.UNSIGNED_INT, 0);
  }
}
```

## 11. トラブルシューティング

### 11.1 よくある問題

#### 問題: 頂点が表示されない
**原因**:
- デプステスト が有効で、頂点ジオメトリがメッシュに隠れている
- 頂点シェーダーでの位置計算が不正確

**解決策**:
```glsl
// デプステスト を無視
gl.disable(gl.DEPTH_TEST);
```

#### 問題: 選択ハイライトがちらつく
**原因**: z-fighting（深度値が等しい）

**解決策**:
```glsl
// ポリゴンオフセットを使用
gl.enable(gl.POLYGON_OFFSET_FILL);
gl.polygonOffset(1.0, 1.0);
```

#### 問題: グレースケール表示が暗すぎる
**原因**: アンビエント光が不足

**解決策**:
```glsl
// アンビエント光を増加
vec3 finalColor = baseColor * (0.7 + 0.3 * diffuse);
```

## 12. 拡張性

### 12.1 カスタムシェーダーの追加

ユーザーがカスタムシェーダーを追加できるようにするための構造：

```typescript
interface CustomShader {
  name: string;
  vertexSource: string;
  fragmentSource: string;
  uniforms: { [key: string]: any };
}

function registerCustomShader(shader: CustomShader): void {
  const vertShader = compileShader(gl, shader.vertexSource, gl.VERTEX_SHADER);
  const fragShader = compileShader(gl, shader.fragmentSource, gl.FRAGMENT_SHADER);
  const program = linkProgram(gl, vertShader, fragShader);
  
  customShaders.set(shader.name, {
    program,
    uniforms: shader.uniforms
  });
}
```

### 12.2 将来の拡張予定

- **ノーマルマップ対応**: より詳細なサーフェス表現
- **PBRマテリアル**: メタリック、ラフネス、環境マップ
- **カスタムテクスチャ**: ユーザーがテクスチャを指定可能
- **アニメーション対応**: キーフレームアニメーション時のシェーダー拡張

## 13. テスト戦略

### 13.1 単体テスト

- シェーダーのコンパイル成功確認
- uniform 変数の正しい設定確認
- 各シェーダーの出力色が期待値と一致するか

### 13.2 ビジュアルテスト

- 頂点ハイライトが正しく表示される
- 選択状態の黄色ハイライトが表示される
- 隣接オブジェクトがグレースケール + 半透明で表示される
- 異なる視点でのシェーダー出力の確認

### 13.3 パフォーマンステスト

- 大量頂点（10,000+）での描画フレームレート確認
- シェーダー切り替え時のパフォーマンス
- メモリ使用量の測定
