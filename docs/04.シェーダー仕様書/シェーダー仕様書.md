# シェーダー仕様書

## 1. 概要

Boxel Editorでは、GPU効率を最適化するためにシェーダーベースのレンダリングを採用しています。グリッド線表示をシェーダーで処理することで、CPU負荷を軽減し、高速なレンダリングを実現しています。

## 2. 現在の実装方式

### 2.1 グリッド線シェーダー（Grid Line Shader）

グリッド線シェーダーは、バリセントリック座標を使用してボクセル面のエッジを検出し、効率的にグリッド線を描画します。

#### 2.1.1 概要

- **目的**: ボクセルメッシュの面のグリッド線を GPU で処理し、CPU 負荷を削減
- **方式**: バリセントリック座標を用いたエッジ検出
- **パフォーマンス**: LineSegments を使用した従来方式と比べて大幅に高速化

#### 2.1.2 入力属性

| 属性名 | 型 | 説明 |
|-------|-----|------|
| position | vec3 | 頂点座標（ワールド空間） |
| barycentric | vec3 | バリセントリック座標（エッジ検出用） |
| normal | vec3 | 面の法線ベクトル |

バリセントリック座標の値：
- 頂点 v0: (1, 0, 0)
- 頂点 v1: (0, 1, 0)
- 頂点 v2: (0, 0, 1)
- 頂点 v3: (1, 0, 0)（四角形の4番目の頂点）

#### 2.1.3 Uniform パラメータ

| Uniform 名 | 型 | デフォルト値 | 説明 |
|-----------|-----|----------|------|
| uColor | vec3 | 可変 | フェイスの色（RGB, 0.0-1.0） |

#### 2.1.4 頂点シェーダー（voxel.vert）

```glsl
attribute vec3 barycentric;
varying vec3 vBarycentric;

void main() {
  vBarycentric = barycentric;
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
}
```

**処理内容**:
- バリセントリック座標をフラグメントシェーダーに渡す
- 標準的な Three.js 座標変換を使用

#### 2.1.5 フラグメントシェーダー（voxel.frag）

```glsl
varying vec3 vBarycentric;
uniform vec3 uColor;

void main() {
  // バリセントリック座標の最小値を計算
  float d = min(vBarycentric.x, min(vBarycentric.y, vBarycentric.z));
  
  // エッジの幅を制御（fwidth で自動的にスクリーン空間に合わせる）
  float edgeWidth = fwidth(d) * 1.5;
  float edge = smoothstep(edgeWidth, 0.0, d);
  
  // フェイスカラーとグリッド線を混合
  vec3 gridColor = vec3(0.0);  // 黒色
  vec3 finalColor = mix(uColor, gridColor, edge);
  
  gl_FragColor = vec4(finalColor, 1.0);
}
```

**処理内容**:
1. **エッジ距離の計算**: バリセントリック座標の最小値を使用
   - 三角形のエッジに近いほど値が小さくなる
   
2. **スクリーン空間での自動調整**: `fwidth()` を使用
   - スクリーン上でのピクセル変化率を計算
   - 解像度に依存しない一定の見た目を実現
   
3. **エッジの滑らか化**: `smoothstep()` で Hermite 補間
   - アンチエイリアシング効果
   - `edgeWidth * 1.5` で線の太さを制御
   
4. **色のブレンディング**: `mix()` で混合
   - エッジ部分を黒色（#000000）に
   - フェイス部分は元のカラーを維持

#### 2.1.6 パフォーマンス特性

- **メモリ効率**: LineSegments メモリを削減（1/3 以下）
- **ドローコール**: LineSegments を排除
- **GPU 処理**: フラグメント単位での処理により効率的
- **レスポンシブ**: 画面解像度の変更に自動対応

### 2.2 従来の実装との比較

| 項目 | 従来方式（LineSegments） | 新方式（Shader） |
|-----|----------------------|----------------|
| メモリ使用量 | 高（辺ジオメトリを保存） | 低 |
| ドローコール | 多（メッシュごと） | 少ない |
| CPU 負荷 | 高い | 低い |
| GPU 負荷 | 低い | 中程度 |
| FPS | 低下 | 向上 |
| グリッド線の品質 | 可変 | 安定 |

## 3. 将来のシェーダー実装予定

### 3.1 シェーダーペア構想

以下のシェーダーペアの実装が予定されています：

1. **ボクセルメッシュシェーダー**（ボクセルの面表示）
   - 頂点シェーダー: `voxel.vert`
   - フラグメントシェーダー: `voxel.frag`

2. **ボクセル境界シェーダー**（ボクセル境界線の表示）
   - 頂点シェーダー: `boundary.vert`
   - フラグメントシェーダー: `boundary.frag`

3. **頂点ハイライトシェーダー**（頂点表示）
   - 頂点シェーダー: `vertex_highlight.vert`
   - フラグメントシェーダー: `vertex_highlight.frag`

4. **選択ハイライトシェーダー**（選択状態表示）
   - 頂点シェーダー: `selection.vert`
   - フラグメントシェーダー: `selection.frag`

5. **隣接オブジェクト用シェーダー**（グレースケール表示）
   - 頂点シェーダー: `adjacent.vert`
   - フラグメントシェーダー: `adjacent.frag`
uniform vec3 uLightPosition;      // ライト位置
uniform vec3 uLightColor;         // ライトカラー（デフォルト: 白色）
uniform float uAmbientIntensity;  // アンビエント強度（デフォルト: 0.5）

// 出力
out vec4 outColor;

void main() {
  // ライト方向
  vec3 lightDir = normalize(uLightPosition - vPosition);
  
  // ビュー方向
  vec3 viewDir = normalize(uCameraPosition - vPosition);
  
  // アンビエント光
  vec3 ambient = vColor * uAmbientIntensity;
  
  // ディフューズ光
  float diffuse = max(dot(vNormal, lightDir), 0.0);
  vec3 diffuseColor = vColor * diffuse * uLightColor;
  
  // スペキュラー光（ボクセルは通常スペキュラーは弱い）
  vec3 reflectDir = reflect(-lightDir, vNormal);
  float specular = pow(max(dot(viewDir, reflectDir), 0.0), 16.0);
  vec3 specularColor = uLightColor * specular * 0.3;
  
  // 最終色
  vec3 finalColor = ambient + diffuseColor + specularColor;
  
  outColor = vec4(finalColor, 1.0);
}
```

## 4. ボクセル境界シェーダー

### 4.1 概要

ボクセルの境界線を明確に表示するシェーダー。ボクセルメッシュの面と面の境界に線を描画し、ボクセルの構造を視覚的に強調する。

### 4.2 頂点シェーダー（boundary.vert）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 aPosition;                // 頂点座標
in vec3 aNormal;                  // 面の法線
in vec3 aBarycentric;             // 重心座標（エッジ検出用）

// uniform
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

// 出力
out vec3 vBarycentric;            // 重心座標
out vec3 vNormal;                 // 法線

void main() {
  vec3 worldPosition = vec3(uModelMatrix * vec4(aPosition, 1.0));
  vNormal = normalize(uNormalMatrix * aNormal);
  vBarycentric = aBarycentric;     // 重心座標をフラグメントシェーダーに渡す
  
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(worldPosition, 1.0);
}
```

**重心座標について**: 三角形の各頂点に (1, 0, 0), (0, 1, 0), (0, 0, 1) を設定することで、エッジ付近で値が急激に変わる特性を利用する。

### 4.3 フラグメントシェーダー（boundary.frag）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 vBarycentric;
in vec3 vNormal;

// uniform
uniform vec3 uBoundaryColor;      // 境界線色（デフォルト: 黒色 #000000）
uniform float uBoundaryWidth;     // 境界線の幅（デフォルト: 0.02）
uniform vec3 uFaceColor;          // 面の基本色（各面の色）
uniform float uBoundaryIntensity; // 境界線の濃度（デフォルト: 0.8）

// 出力
out vec4 outColor;

void main() {
  // 重心座標の最小値を計算（エッジからの距離を表す）
  float minBary = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);
  
  // エッジの判定（線形ステップで滑らかに遷移）
  float edge = smoothstep(uBoundaryWidth, uBoundaryWidth * 1.5, minBary);
  
  // 面の色と境界線色をブレンド
  vec3 finalColor = mix(uBoundaryColor, uFaceColor, edge);
  
  // 境界線の濃度を適用
  float alpha = 1.0;
  if (minBary < uBoundaryWidth) {
    alpha = uBoundaryIntensity;
  }
  
  outColor = vec4(finalColor, alpha);
}
```

### 4.4 描画方式

**オプション1: 重心座標ベース（推奨）**
- 三角形メッシュの各三角形に対して重心座標を頂点属性として設定
- フラグメントシェーダー内でエッジを検出し、線を描画
- メッシュ分割やジオメトリシェーダーが不要
- モバイルデバイスでも高速

**オプション2: ワイヤーフレーム描画**
```glsl
// ジオメトリシェーダーを使用する方式（将来の拡張）
// GL_TRIANGLES_ADJACENCY を使用して隣接情報を取得
// フラグメントシェーダーで法線の角度差を計算
```

**オプション3: エッジベース描画**
- メッシュの構造から明示的にエッジを抽出
- 別途エッジメッシュを用意して描画
- より高速だが、メモリ消費が多い

## 5. 頂点ハイライトシェーダー

### 4.1 概要

頂点をスフィア（球体）として描画し、選択状態や常時表示の青色ハイライトを実現する。

### 5.2 頂点シェーダー（vertex_highlight.vert）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 aPosition;                // 頂点座標
in vec3 aOffset;                  // スフィアメッシュのオフセット

// uniform
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform float uVertexSize;        // 頂点スフィアのサイズ（デフォルト: 0.5）
uniform float uHighlightSize;     // ハイライト時のサイズ（デフォルト: 0.8）
uniform bool uIsSelected;         // 選択状態フラグ

// 出力
out float vAlpha;                 // 不透明度

void main() {
  // スフィアのサイズを決定
  float size = uIsSelected ? uHighlightSize : uVertexSize;
  
  // スフィアのメッシュをスケール
  vec3 scaledOffset = aOffset * size;
  
  // 最終頂点座標
  vec3 worldPosition = vec3(uModelMatrix * vec4(aPosition, 1.0)) + scaledOffset;
  
  // アルファ値（選択時は不透明度を上げる）
  vAlpha = uIsSelected ? 1.0 : 0.7;
  
  // クリップ空間の座標
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(worldPosition, 1.0);
}
```

### 5.3 フラグメントシェーダー（vertex_highlight.frag）

```glsl
#version 300 es
precision highp float;

// 入力
in float vAlpha;

// uniform
uniform vec3 uVertexColor;        // 頂点カラー（デフォルト: #4A90E2 青色）
uniform float uGlow;              // グロウ強度（デフォルト: 0.2）

// 出力
out vec4 outColor;

void main() {
  // スフィアの表面を滑らかに描画するため、gl_PointCoord を使用
  // （ただし、メッシュベースの場合は標準の法線ベースシェーディングを使用）
  
  // 頂点カラーにグロウ効果を追加
  vec3 glowColor = uVertexColor * (1.0 + uGlow);
  
  outColor = vec4(glowColor, vAlpha);
}
```

## 6. 選択ハイライトシェーダー

### 6.1 概要

ボクセルの選択状態を視覚的に表現するためのシェーダー。選択された面をグリッド線付きで暗い色で描画し、選択状態を明確に示します。

**実装方式**: グリッド線シェーダーと同じバリセントリック座標ベースのエッジ検出を使用し、選択状態では色を暗くすることで視覚的フィードバックを提供します。

### 6.2 頂点シェーダー（selection.vert）

```glsl
attribute vec3 barycentric;
attribute vec3 normal;

varying vec3 vBarycentric;
varying vec3 vNormal;

void main() {
  vBarycentric = barycentric;
  vNormal = normalize(normalMatrix * normal);
  
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);
}
```

**処理内容**:
- バリセントリック座標を保存（グリッド線検出用）
- 法線ベクトルを保存（将来の拡張用）
- 標準的な Three.js 座標変換

### 6.3 フラグメントシェーダー（selection.frag）

```glsl
varying vec3 vBarycentric;
varying vec3 vNormal;

uniform vec3 uColor;

void main() {
  // グリッド線の処理（選択色の上に表示）
  vec3 bary = vBarycentric;
  float minBary = min(min(bary.x, bary.y), bary.z);
  float edge = smoothstep(0.02, 0.01, minBary);
  
  // グリッド線を黒で描画、それ以外は選択色
  gl_FragColor = edge > 0.5 ? vec4(0.0, 0.0, 0.0, 1.0) : vec4(uColor * 0.8, 1.0);
}
```

**処理内容**:
1. **エッジ検出**: バリセントリック座標を使用してグリッド線位置を検出
2. **線の描画**: `smoothstep()` でアンチエイリアシングされた黒色の線
3. **選択色の適用**: `uColor * 0.8` で暗い選択色を適用
4. **視覚的フィードバック**: グリッド線付きの暗い色により、選択状態を明確に表現

### 6.4 Uniform パラメータ

| Uniform 名 | 型 | デフォルト値 | 説明 |
|-----------|-----|----------|------|
| uColor | vec3 | 可変（選択時の色） | 選択色（RGB, 0.0-1.0） |

### 6.5 入力属性

| 属性名 | 型 | 説明 |
|-------|-----|------|
| barycentric | vec3 | バリセントリック座標（グリッド線検出用） |
| normal | vec3 | 面の法線ベクトル（将来の拡張用） |
| position | vec3 | 頂点座標（ワールド空間） |

### 6.6 実装の特徴

- **グリッド線シェーダーとの統一**: 同じバリセントリック座標ベースのアプローチ
- **パフォーマンス**: 追加の幾何学的計算なし（色の暗度のみ変更）
- **視認性**: グリッド線により選択状態がより明確
- **柔軟性**: uColor の値を変更することで、任意の選択色に対応

### 6.7 使用フロー

1. **通常表示**: `uColor` = フェイスの元の色、グリッド線シェーダーを使用
2. **ホバー状態**: `uColor` = ホバー色、選択シェーダーを適用
3. **選択状態**: `uColor` = 選択色、選択シェーダーを適用
4. **解除**: 元の色でグリッド線シェーダーに戻す

## 7. 隣接オブジェクト用シェーダー

### 7.1 概要

隣接オブジェクトをグレースケール表示する。元の着色情報を無視し、灰色で統一された表示を行う。

### 7.2 頂点シェーダー（adjacent.vert）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 aPosition;
in vec3 aNormal;

// uniform
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

// 出力
out vec3 vPosition;
out vec3 vNormal;

void main() {
  vPosition = vec3(uModelMatrix * vec4(aPosition, 1.0));
  vNormal = normalize(uNormalMatrix * aNormal);
  
  gl_Position = uProjectionMatrix * uViewMatrix * vec4(vPosition, 1.0);
}
```

### 7.3 フラグメントシェーダー（adjacent.frag）

```glsl
#version 300 es
precision highp float;

// 入力
in vec3 vPosition;
in vec3 vNormal;

// uniform
uniform vec3 uCameraPosition;
uniform vec3 uLightPosition;
uniform float uAdjacentAlpha;     // 隣接オブジェクトのアルファ値（デフォルト: 0.75）

// 出力
out vec4 outColor;

void main() {
  // グレースケール色（固定値）
  vec3 baseColor = vec3(0.533, 0.533, 0.533); // #888888
  
  // ライト計算（アンビエント + ディフューズ）
  vec3 lightDir = normalize(uLightPosition - vPosition);
  float diffuse = max(dot(vNormal, lightDir), 0.0);
  
  vec3 finalColor = baseColor * (0.5 + 0.5 * diffuse);
  
  outColor = vec4(finalColor, uAdjacentAlpha);
}
```

## 8. uniform 変数の管理

### 8.1 共通 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uModelMatrix | mat4 | 単位行列 | モデル変換行列 |
| uViewMatrix | mat4 | 単位行列 | ビュー変換行列 |
| uProjectionMatrix | mat4 | 単位行列 | プロジェクション行列 |
| uNormalMatrix | mat3 | 単位行列 | 法線変換行列 |
| uCameraPosition | vec3 | (0, 0, 0) | カメラの位置 |

### 8.2 ライト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uLightPosition | vec3 | (50, 50, 50) | ライトの位置 |
| uLightColor | vec3 | (1, 1, 1) | ライトの色（白色） |
| uAmbientIntensity | float | 0.5 | アンビエント光の強度 |

### 8.3 ボクセル境界関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uBoundaryColor | vec3 | (0, 0, 0) | 境界線色（黒） |
| uBoundaryWidth | float | 0.02 | 境界線の幅 |
| uFaceColor | vec3 | (1, 1, 1) | ボクセル面の色 |
| uBoundaryIntensity | float | 0.8 | 境界線の濃度 |

### 8.4 頂点ハイライト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uVertexSize | float | 0.5 | 頂点スフィアのサイズ |
| uHighlightSize | float | 0.8 | 選択時の頂点スフィアのサイズ |
| uVertexColor | vec3 | (0.29, 0.56, 0.89) | 頂点カラー（#4A90E2） |
| uGlow | float | 0.2 | グロウ効果の強度 |
| uIsSelected | bool | false | 頂点が選択されているかどうか |

### 8.5 選択ハイライト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uSelectionColor | vec3 | (1, 1, 0) | 選択色（黄色） |
| uSelectionIntensity | float | 0.8 | 選択ハイライトの不透明度 |
| uOutlineWidth | float | 0.05 | アウトラインの幅 |

### 8.6 隣接オブジェクト関連 uniform

| 名前 | 型 | デフォルト値 | 説明 |
| --- | --- | --- | --- |
| uAdjacentAlpha | float | 0.75 | 隣接オブジェクトのアルファ値 |

## 9. シェーダープログラム管理

### 9.1 シェーダーコンパイル

```typescript
function compileShader(
  gl: WebGL2RenderingContext,
  source: string,
  type: number
): WebGLShader {
  const shader = gl.createShader(type)!;
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(
      "シェーダーのコンパイル失敗:",
      gl.getShaderInfoLog(shader)
    );
    gl.deleteShader(shader);
    throw new Error("シェーダーのコンパイルに失敗しました");
  }
  
  return shader;
}
```

### 9.2 シェーダープログラムリンク

```typescript
function linkProgram(
  gl: WebGL2RenderingContext,
  vertexShader: WebGLShader,
  fragmentShader: WebGLShader
): WebGLProgram {
  const program = gl.createProgram()!;
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(
      "シェーダープログラムのリンク失敗:",
      gl.getProgramInfoLog(program)
    );
    gl.deleteProgram(program);
    throw new Error("シェーダープログラムのリンクに失敗しました");
  }
  
  return program;
}
```

### 9.3 uniform 変数の設定

```typescript
function setUniforms(
  gl: WebGL2RenderingContext,
  program: WebGLProgram,
  uniforms: { [key: string]: any }
): void {
  gl.useProgram(program);
  
  for (const [name, value] of Object.entries(uniforms)) {
    const location = gl.getUniformLocation(program, name);
    if (!location) continue;
    
    if (typeof value === "number") {
      gl.uniform1f(location, value);
    } else if (Array.isArray(value)) {
      if (value.length === 2) {
        gl.uniform2fv(location, value);
      } else if (value.length === 3) {
        gl.uniform3fv(location, value);
      } else if (value.length === 4) {
        gl.uniform4fv(location, value);
      } else if (value.length === 9) {
        gl.uniformMatrix3fv(location, false, value);
      } else if (value.length === 16) {
        gl.uniformMatrix4fv(location, false, value);
      }
    } else if (typeof value === "boolean") {
      gl.uniform1i(location, value ? 1 : 0);
    }
  }
}
```

## 10. 描画パイプライン

### 10.1 レンダリング順序

```
1. メインオブジェクトのボクセルメッシュを描画
   - シェーダー: voxel.vert / voxel.frag
   - ブレンドモード: Opaque
   
2. ボクセル境界線を描画
   - シェーダー: boundary.vert / boundary.frag
   - ブレンドモード: Opaque
   - デプステスト: 有効（メッシュの前面に描画）
   
3. 隣接オブジェクトのメッシュを描画
   - シェーダー: adjacent.vert / adjacent.frag
   - ブレンドモード: Blend（Alpha）
   
4. 頂点ハイライトを描画（メインオブジェクト）
   - シェーダー: vertex_highlight.vert / vertex_highlight.frag
   - ブレンドモード: Additive
   - デプステスト: 常に描画（gl.disable(gl.DEPTH_TEST)）
   
5. 選択ハイライトを描画
   - シェーダー: selection.vert / selection.frag
   - ブレンドモード: Blend（Alpha）
```

### 10.2 実装例

```typescript
function render(): void {
  gl.clearColor(0.2, 0.2, 0.2, 1.0);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  // 1. メインオブジェクト描画
  gl.useProgram(voxelProgram);
  setUniforms(gl, voxelProgram, {
    uModelMatrix: mainObject.matrix,
    uViewMatrix: camera.viewMatrix,
    uProjectionMatrix: camera.projectionMatrix,
    uLightPosition: lightPosition
  });
  gl.drawElements(gl.TRIANGLES, mainObject.indexCount, gl.UNSIGNED_INT, 0);
  
  // 2. ボクセル境界線描画
  gl.useProgram(boundaryProgram);
  setUniforms(gl, boundaryProgram, {
    uModelMatrix: mainObject.matrix,
    uViewMatrix: camera.viewMatrix,
    uProjectionMatrix: camera.projectionMatrix,
    uBoundaryColor: [0, 0, 0],
    uBoundaryWidth: 0.02,
    uFaceColor: [1, 1, 1],
    uBoundaryIntensity: 0.8
  });
  gl.drawElements(gl.TRIANGLES, mainObject.indexCount, gl.UNSIGNED_INT, 0);
  
  // 3. 隣接オブジェクト描画
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  for (const adjacent of adjacentObjects) {
    gl.useProgram(adjacentProgram);
    setUniforms(gl, adjacentProgram, {
      uModelMatrix: adjacent.matrix,
      uViewMatrix: camera.viewMatrix,
      uProjectionMatrix: camera.projectionMatrix,
      uAdjacentAlpha: 0.75
    });
    gl.drawElements(gl.TRIANGLES, adjacent.indexCount, gl.UNSIGNED_INT, 0);
  }
  
  // 4. 頂点ハイライト描画
  gl.disable(gl.DEPTH_TEST);
  gl.blendFunc(gl.ONE, gl.ONE); // Additive blend
  gl.useProgram(vertexHighlightProgram);
  setUniforms(gl, vertexHighlightProgram, {
    uVertexColor: [0.29, 0.56, 0.89],
    uVertexSize: 0.5
  });
  gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
  gl.enable(gl.DEPTH_TEST);
  
  // 5. 選択ハイライト描画
  if (selectedFace) {
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(selectionProgram);
    setUniforms(gl, selectionProgram, {
      uSelectionColor: [1, 1, 0],
      uOutlineWidth: 0.05
    });
    gl.drawElements(gl.TRIANGLES, selectedFace.indexCount, gl.UNSIGNED_INT, 0);
  }
}
```

## 11. パフォーマンス最適化

### 11.1 シェーダーの最適化

- **uniform の事前計算**: 毎フレーム計算する必要のない値はアプリケーション側で事前計算
- **精度の調整**: 必要に応じて `lowp` / `mediump` を使用（モバイル対応）
- **演算量削減**: 複雑な計算（例: 正規化）は可能な限り頂点シェーダーで実行

### 11.2 バッチ処理

```typescript
// 同一シェーダー＆同一マテリアルの描画をまとめる
function renderBatch(
  meshes: Mesh[],
  program: WebGLProgram
): void {
  gl.useProgram(program);
  
  for (const mesh of meshes) {
    gl.bindVertexArray(mesh.vao);
    gl.uniformMatrix4fv(
      gl.getUniformLocation(program, "uModelMatrix"),
      false,
      mesh.matrix
    );
    gl.drawElements(gl.TRIANGLES, mesh.indexCount, gl.UNSIGNED_INT, 0);
  }
}
```

## 12. トラブルシューティング

### 12.1 よくある問題

#### 問題: 頂点が表示されない
**原因**:
- デプステスト が有効で、頂点ジオメトリがメッシュに隠れている
- 頂点シェーダーでの位置計算が不正確

**解決策**:
```glsl
// デプステスト を無視
gl.disable(gl.DEPTH_TEST);
```

#### 問題: 選択ハイライトがちらつく
**原因**: z-fighting（深度値が等しい）

**解決策**:
```glsl
// ポリゴンオフセットを使用
gl.enable(gl.POLYGON_OFFSET_FILL);
gl.polygonOffset(1.0, 1.0);
```

#### 問題: グレースケール表示が暗すぎる
**原因**: アンビエント光が不足

**解決策**:
```glsl
// アンビエント光を増加
vec3 finalColor = baseColor * (0.7 + 0.3 * diffuse);
```

## 13. 拡張性

### 13.1 カスタムシェーダーの追加

ユーザーがカスタムシェーダーを追加できるようにするための構造：

```typescript
interface CustomShader {
  name: string;
  vertexSource: string;
  fragmentSource: string;
  uniforms: { [key: string]: any };
}

function registerCustomShader(shader: CustomShader): void {
  const vertShader = compileShader(gl, shader.vertexSource, gl.VERTEX_SHADER);
  const fragShader = compileShader(gl, shader.fragmentSource, gl.FRAGMENT_SHADER);
  const program = linkProgram(gl, vertShader, fragShader);
  
  customShaders.set(shader.name, {
    program,
    uniforms: shader.uniforms
  });
}
```

### 13.2 将来の拡張予定

- **ノーマルマップ対応**: より詳細なサーフェス表現
- **PBRマテリアル**: メタリック、ラフネス、環境マップ
- **カスタムテクスチャ**: ユーザーがテクスチャを指定可能
- **アニメーション対応**: キーフレームアニメーション時のシェーダー拡張

## 14. テスト戦略

### 14.1 単体テスト

- シェーダーのコンパイル成功確認
- uniform 変数の正しい設定確認
- 各シェーダーの出力色が期待値と一致するか

### 14.2 ビジュアルテスト

- 頂点ハイライトが正しく表示される
- 選択状態の黄色ハイライトが表示される
- **ボクセル境界線が黒色で明確に表示される**
- 隣接オブジェクトがグレースケール + 半透明で表示される
- 異なる視点でのシェーダー出力の確認

### 14.3 パフォーマンステスト

- 大量頂点（10,000+）での描画フレームレート確認
- シェーダー切り替え時のパフォーマンス
- メモリ使用量の測定
