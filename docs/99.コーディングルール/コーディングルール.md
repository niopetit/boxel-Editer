# Boxel Editor コーディングルール

**最終更新**: 2026年1月3日  
**対象**: TypeScript/React/Electron/Three.jsプロジェクト

## 1. ファイル・フォルダ構成

### 1.1 ファイル命名規則

#### TypeScript/JavaScript
- **コンポーネント**: PascalCase（例: `CanvasComponent.tsx`, `ColorPalette.tsx`）
- **ユーティリティ・ライブラリ**: camelCase（例: `vectorUtils.ts`, `fileHandler.ts`）
- **定数ファイル**: UPPER_SNAKE_CASE（例: `CONSTANTS.ts`, `VOXEL_CONFIG.ts`）
- **テストファイル**: `[名前].test.ts` または `[名前].spec.ts`

#### その他
- **画像・アセット**: kebab-case（例: `icon-save.png`, `color-palette.svg`）
- **マークダウン**: 日本語またはkebab-case（例: `README.md`, `camera-specification.md`）

### 1.2 フォルダ構成推奨

```
src/
├── main/                      # Electron メインプロセス
│   └── index.ts
├── preload/                   # Preload スクリプト
│   ├── index.ts
│   └── index.d.ts
├── renderer/                  # レンダラープロセス（React）
│   ├── index.html
│   ├── src/
│   │   ├── App.tsx
│   │   ├── main.tsx
│   │   ├── env.d.ts
│   │   ├── components/        # Reactコンポーネント
│   │   │   ├── CanvasComponent.tsx
│   │   │   ├── SidePanel.tsx
│   │   │   ├── ColorPalette.tsx
│   │   │   └── MenuBar.tsx
│   │   ├── hooks/             # カスタムReactフック
│   │   │   ├── useVoxelState.ts
│   │   │   ├── useCamera.ts
│   │   │   └── useColorPalette.ts
│   │   ├── utils/             # ユーティリティ関数
│   │   │   ├── vectorUtils.ts
│   │   │   ├── voxelUtils.ts
│   │   │   ├── fileHandler.ts
│   │   │   └── undoRedo.ts
│   │   ├── types/             # 型定義
│   │   │   ├── voxel.ts
│   │   │   ├── camera.ts
│   │   │   └── common.ts
│   │   └── styles/            # スタイルシート
│   │       ├── App.css
│   │       └── components/
│   └── public/                # 静的アセット
└── three/                     # Three.js関連
    ├── shaders/               # シェーダーファイル
    │   ├── vertex.glsl
    │   └── fragment.glsl
    ├── scene.ts               # シーン管理
    └── materials.ts           # マテリアル定義
```

## 2. TypeScript コーディング規則

### 2.1 型定義

#### インターフェースと型の使い分け
- **Interface**: 複数の実装が必要な場合、継承が必要な場合
- **Type**: 単純な型の結合、ユニオン型、タプル型の場合

```typescript
// Good: Interfaceはポリモーフィズムに適している
interface IVoxelRenderer {
  render(): void;
  dispose(): void;
}

// Good: Typeはシンプルな型結合に適している
type VoxelPosition = [number, number, number];
type Color = string | [number, number, number];
```

#### 型定義ファイルの場所
- グローバルな型は `src/renderer/src/types/` に集約
- コンポーネント固有の型はコンポーネントファイル内に定義
- 三.js関連の型は `src/three/` に定義

### 2.2 変数・関数命名規則

```typescript
// 定数: UPPER_SNAKE_CASE
const MAX_GRID_SIZE = 50;
const DEFAULT_VOXEL_COLOR = '#FFFFFF';

// 変数・パラメータ: camelCase
const voxelPosition = [0, 0, 0];
let selectedFaceIndex = -1;

// 関数: camelCase
function calculateVoxelBounds(position: VoxelPosition): Bounds {}

// プライベート関数・プロパティ: _camelCase
class VoxelManager {
  private _voxelGrid: Voxel[][] = [];
  
  private _initializeGrid(): void {}
}

// イベントハンドラ: on[Event] または handle[Event]
function onCanvasClick(event: MouseEvent): void {}
function handleKeyDown(event: KeyboardEvent): void {}

// Booleanプレフィックス: is, has, can
const isSelected = true;
const hasChildren = false;
const canDelete = true;
```

### 2.3 クラス設計

```typescript
// Good: 単一責任の原則に従う
class VoxelGridManager {
  private grid: Voxel[][][] = [];
  
  addVoxel(position: VoxelPosition): boolean {}
  removeVoxel(position: VoxelPosition): boolean {}
  getVoxel(position: VoxelPosition): Voxel | null {}
}

// Good: 依存性をコンストラクタで注入
class VoxelRenderer {
  constructor(
    private scene: THREE.Scene,
    private gridManager: VoxelGridManager
  ) {}
  
  render(): void {}
}

// Avoid: 深いネストクラスは避ける
```

### 2.4 関数設計

```typescript
// Good: 関数は単一の責任を持つ
function calculateFaceNormal(
  vertex1: Vector3,
  vertex2: Vector3,
  vertex3: Vector3
): Vector3 {
  // 法線計算ロジック
}

// Good: 関数の引数は3個以下が目安
function saveBLWFile(
  filePath: string,
  voxelData: VoxelData,
  metadata: FileMetadata
): Promise<void> {}

// Avoid: 多くの引数を持つ関数は避ける（インターフェースで代替）
// Bad:
// function saveFile(path, data, meta, grid, undo, redo, settings) {}

// Good: インターフェースを使用
interface SaveOptions {
  filePath: string;
  voxelData: VoxelData;
  metadata: FileMetadata;
  gridConfig: GridConfig;
  includeUndoHistory?: boolean;
}

function saveFile(options: SaveOptions): Promise<void> {}
```

## 3. React コーディング規則

### 3.1 コンポーネント設計

```typescript
// Good: 関数コンポーネント + Hooks を使用
import { FC, useState, useCallback } from 'react';

interface CanvasComponentProps {
  width: number;
  height: number;
  onVoxelSelect?: (voxelId: string) => void;
}

const CanvasComponent: FC<CanvasComponentProps> = ({
  width,
  height,
  onVoxelSelect,
}) => {
  const [selectedVoxel, setSelectedVoxel] = useState<string | null>(null);
  
  const handleCanvasClick = useCallback((e: React.MouseEvent) => {
    // ロジック
  }, []);
  
  return <canvas width={width} height={height} />;
};

export default CanvasComponent;

// Avoid: クラスコンポーネントは新規に作成しない
```

### 3.2 Hooks 使用規則

```typescript
// Good: カスタムフックで複雑なロジックをカプセル化
function useVoxelState() {
  const [voxels, setVoxels] = useState<Voxel[]>([]);
  const [selectedVoxelId, setSelectedVoxelId] = useState<string | null>(null);
  
  const addVoxel = useCallback((position: VoxelPosition) => {
    // ロジック
  }, []);
  
  return { voxels, selectedVoxelId, addVoxel };
}

// Good: useCallbackでパフォーマンス最適化
const handleClick = useCallback((e: MouseEvent) => {
  // イベントハンドリング
}, [dependency1, dependency2]);

// Good: 依存配列を正確に指定
useEffect(() => {
  // エフェクト
}, [selectedVoxel, gridSize]);

// Avoid: 依存配列を省略（無限ループの原因）
```

### 3.3 Props 設計

```typescript
// Good: 小さく関心を分離したProps
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary';
}

// Good: デフォルト値の設定
const MyComponent: FC<MyComponentProps> = ({
  enabled = true,
  onSelect = () => {},
}) => {
  // ...
};

// Avoid: Propsオブジェクト全体を再クリエイトしない
```

## 4. Three.js / Graphics コーディング規則

### 4.1 シーン・オブジェクト管理

```typescript
// Good: リソース生存期間を明確に管理
class VoxelSceneManager {
  private scene: THREE.Scene;
  private renderer: THREE.WebGLRenderer;
  private geometry: THREE.BufferGeometry | null = null;
  private material: THREE.Material | null = null;
  
  constructor(canvas: HTMLCanvasElement) {
    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer({ canvas });
    this.setupScene();
  }
  
  private setupScene(): void {
    this.scene.background = new THREE.Color(0x333333);
  }
  
  dispose(): void {
    // メモリリークを防ぐため、必ずクリーンアップ
    this.geometry?.dispose();
    this.material?.dispose();
    this.renderer.dispose();
  }
}

// Good: ジオメトリ、マテリアルは適切に破棄
function createVoxelMesh(position: VoxelPosition): THREE.Mesh {
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const material = new THREE.MeshPhongMaterial({ color: 0xffffff });
  return new THREE.Mesh(geometry, material);
}
```

### 4.2 シェーダー実装

```glsl
/* vertex.glsl */
varying vec3 vPosition;
varying vec3 vNormal;
varying vec4 vColor;

void main() {
  vPosition = position;
  vNormal = normalize(normal);
  vColor = vec4(color, 1.0);
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}

/* fragment.glsl */
varying vec3 vNormal;
varying vec4 vColor;

void main() {
  // 法線に基づいてハイライト
  float intensity = dot(vNormal, normalize(vec3(1.0, 1.0, 1.0)));
  gl_FragColor = vColor * intensity;
}
```

### 4.3 パフォーマンス

```typescript
// Good: 頻繁な再計算を避ける
class VoxelRenderer {
  private cachedBounds: Map<string, Bounds> = new Map();
  
  getVoxelBounds(voxelId: string): Bounds {
    if (!this.cachedBounds.has(voxelId)) {
      this.cachedBounds.set(voxelId, this.calculateBounds(voxelId));
    }
    return this.cachedBounds.get(voxelId)!;
  }
  
  invalidateBoundsCache(voxelId: string): void {
    this.cachedBounds.delete(voxelId);
  }
}

// Good: アップデート時はバッチ処理
function updateMultipleVoxels(voxels: Voxel[]): void {
  // 複数更新はバッチで行う
  voxels.forEach(voxel => {
    voxel.updateGeometry();
  });
  renderer.render(scene, camera);
}

// Avoid: フレームごとに不要なメモリ確保
```

## 5. ファイル形式処理 (BLW・GLTF)

### 5.1 ファイル操作

```typescript
// Good: エラーハンドリングを含める
async function saveBLWFile(
  filePath: string,
  voxelData: VoxelData,
  metadata: FileMetadata
): Promise<void> {
  try {
    const json = {
      version: '1.0',
      metadata,
      voxels: voxelData,
      colors: colorPalette,
    };
    
    const content = JSON.stringify(json, null, 2);
    await fs.writeFile(filePath, content, 'utf-8');
  } catch (error) {
    throw new Error(`Failed to save BLW file: ${error.message}`);
  }
}

// Good: 相対パスではなく絶対パスを使用
const savePath = path.resolve(appDataDir, 'project.blw');

// Good: メタデータの検証
function validateBLWMetadata(metadata: unknown): FileMetadata {
  if (!isValidMetadata(metadata)) {
    throw new Error('Invalid metadata format');
  }
  return metadata as FileMetadata;
}
```

### 5.2 状態復元

```typescript
// Good: BLW読み込み時は完全復元を実装
async function loadBLWFile(filePath: string): Promise<ProjectState> {
  const content = await fs.readFile(filePath, 'utf-8');
  const json = JSON.parse(content);
  
  return {
    voxels: json.voxels,
    colors: json.colors,
    gridConfig: json.metadata.gridConfig,
    cameraState: json.metadata.cameraState,
    undoHistory: json.metadata.undoHistory || [],
  };
}
```

## 6. 状態管理・Undo/Redo

### 6.1 状態管理パターン

```typescript
// Good: イミュータブルな状態管理
type Action =
  | { type: 'ADD_VOXEL'; position: VoxelPosition }
  | { type: 'REMOVE_VOXEL'; voxelId: string }
  | { type: 'PAINT_FACE'; faceId: string; color: Color };

function voxelReducer(state: VoxelState, action: Action): VoxelState {
  switch (action.type) {
    case 'ADD_VOXEL':
      return {
        ...state,
        voxels: [...state.voxels, createVoxel(action.position)],
      };
    case 'REMOVE_VOXEL':
      return {
        ...state,
        voxels: state.voxels.filter(v => v.id !== action.voxelId),
      };
    default:
      return state;
  }
}
```

### 6.2 Undo/Redo 実装

```typescript
// Good: 操作履歴を管理
class UndoRedoManager {
  private history: VoxelState[] = [];
  private currentIndex: number = -1;
  
  push(state: VoxelState): void {
    // 現在位置より後ろの履歴を削除
    this.history = this.history.slice(0, this.currentIndex + 1);
    this.history.push(state);
    this.currentIndex++;
  }
  
  undo(): VoxelState | null {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      return this.history[this.currentIndex];
    }
    return null;
  }
  
  redo(): VoxelState | null {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      return this.history[this.currentIndex];
    }
    return null;
  }
}
```

## 7. エラーハンドリング

### 7.1 カスタムエラークラス

```typescript
// Good: 目的別のカスタムエラー
class ValidationError extends Error {
  constructor(message: string, public details?: unknown) {
    super(message);
    this.name = 'ValidationError';
  }
}

class FileIOError extends Error {
  constructor(message: string, public filePath: string) {
    super(message);
    this.name = 'FileIOError';
  }
}

class RenderError extends Error {
  constructor(message: string, public context?: string) {
    super(message);
    this.name = 'RenderError';
  }
}
```

### 7.2 エラーハンドリングパターン

```typescript
// Good: try-catchとバリデーション
async function processVoxelData(data: unknown): Promise<VoxelData> {
  try {
    if (!isValidVoxelData(data)) {
      throw new ValidationError('Invalid voxel data format');
    }
    
    // 処理
    return data as VoxelData;
  } catch (error) {
    if (error instanceof ValidationError) {
      console.error('Validation failed:', error.details);
    } else if (error instanceof Error) {
      console.error('Unexpected error:', error.message);
    }
    throw error;
  }
}

// Good: 非同期関数のエラーハンドリング
async function loadAndRenderVoxels(): Promise<void> {
  try {
    const data = await loadVoxelData();
    await renderVoxels(data);
  } catch (error) {
    if (error instanceof FileIOError) {
      showUserError(`ファイルの読込に失敗しました: ${error.filePath}`);
    } else if (error instanceof RenderError) {
      showUserError('3D表示に失敗しました');
    } else {
      showUserError('予期しないエラーが発生しました');
    }
  }
}
```

## 8. テスト

### 8.1 テストの構成

```typescript
// Good: ユーティリティ関数のテスト
import { describe, it, expect } from 'vitest';
import { calculateVoxelBounds } from '../utils/voxelUtils';

describe('VoxelUtils', () => {
  it('should calculate bounds correctly', () => {
    const position: VoxelPosition = [1, 2, 3];
    const bounds = calculateVoxelBounds(position);
    
    expect(bounds.min.x).toBe(0.5);
    expect(bounds.max.x).toBe(1.5);
  });
  
  it('should handle edge cases', () => {
    const position: VoxelPosition = [0, 0, 0];
    const bounds = calculateVoxelBounds(position);
    
    expect(bounds).toBeDefined();
  });
});

// Good: Reactコンポーネントのテスト
import { render, screen } from '@testing-library/react';
import CanvasComponent from '../components/CanvasComponent';

describe('CanvasComponent', () => {
  it('should render canvas element', () => {
    render(<CanvasComponent width={800} height={600} />);
    
    const canvas = screen.getByRole('img', { hidden: true });
    expect(canvas).toBeInTheDocument();
  });
});
```

## 9. コメント・ドキュメント

### 9.1 コメント規則

```typescript
// Good: なぜを説明する（何ではなく）
// 重複頂点を削除することでメモリ効率を改善
const uniqueVertices = Array.from(new Set(vertices));

// Good: 複雑なロジックはコメント付与
// ボクセルの頂点位置を計算
// 各ボクセルは8つの頂点を持つため、座標にオフセットを適用
function calculateVertexPositions(voxelPosition: VoxelPosition): Vector3[] {
  const offsets = [
    [0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0],
    [0, 0, 1], [1, 0, 1], [0, 1, 1], [1, 1, 1],
  ];
  
  return offsets.map(offset => ({
    x: voxelPosition[0] + offset[0],
    y: voxelPosition[1] + offset[1],
    z: voxelPosition[2] + offset[2],
  }));
}

// Good: 注意が必要な部分をマーク
// FIXME: メモリリークの可能性 - proper disposalが必要
this.renderer.render(scene, camera);

// Good: TODO項目は明確に
// TODO: ハイライト効果の最適化 (#123参照)
```

### 9.2 JSDocコメント

```typescript
/**
 * 指定座標にボクセルを追加する
 * @param position ボクセルの座標 [x, y, z]
 * @returns 追加に成功した場合true、失敗した場合false
 * @throws {ValidationError} 無効な座標が渡された場合
 * @example
 * const success = voxelManager.addVoxel([5, 3, 2]);
 */
function addVoxel(position: VoxelPosition): boolean {}

/**
 * カメラを指定方向に回転させる
 * @param direction 回転方向 ('up' | 'down' | 'left' | 'right')
 * @param angle 回転角度（度数法）
 */
function rotateCamera(
  direction: 'up' | 'down' | 'left' | 'right',
  angle: number = 5
): void {}
```

## 10. パフォーマンス最適化

### 10.1 レンダリング最適化

```typescript
// Good: フレームレート管理
class RenderLoop {
  private frameId: number | null = null;
  private lastRenderTime: number = 0;
  private targetFrameRate: number = 60;
  
  start(): void {
    const frame = () => {
      const now = performance.now();
      if (now - this.lastRenderTime >= 1000 / this.targetFrameRate) {
        this.render();
        this.lastRenderTime = now;
      }
      this.frameId = requestAnimationFrame(frame);
    };
    this.frameId = requestAnimationFrame(frame);
  }
  
  private render(): void {
    // レンダリング処理
  }
}

// Good: ジオメトリの再利用
class VoxelGeometryCache {
  private cache: Map<string, THREE.BufferGeometry> = new Map();
  
  getOrCreate(key: string): THREE.BufferGeometry {
    if (!this.cache.has(key)) {
      this.cache.set(key, this.createGeometry(key));
    }
    return this.cache.get(key)!;
  }
  
  clear(): void {
    this.cache.forEach(geometry => geometry.dispose());
    this.cache.clear();
  }
}
```

### 10.2 メモリ管理

```typescript
// Good: WeakMapで自動ガベージコレクション
class VoxelMetadata {
  private metadata = new WeakMap<object, any>();
  
  set(voxel: object, data: any): void {
    this.metadata.set(voxel, data);
  }
  
  get(voxel: object): any {
    return this.metadata.get(voxel);
  }
}

// Good: 大きなバッファは明示的に解放
function releaseBuffers(): void {
  this.geometry?.dispose();
  this.material?.dispose();
  this.texture?.dispose();
}
```

## 11. 開発環境・ツーリング

### 11.1 推奨ツール

- **言語**: TypeScript 5.x以上
- **パッケージマネージャー**: npm
- **ビルドツール**: Vite
- **テストフレームワーク**: Vitest
- **Linter**: ESLint
- **Formatter**: Prettier
- **型チェック**: TypeScript strict mode

### 11.2 ESLint 設定（推奨）

```json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended"
  ],
  "rules": {
    "@typescript-eslint/explicit-function-return-types": "warn",
    "@typescript-eslint/no-explicit-any": "error",
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        "argsIgnorePattern": "^_"
      }
    ],
    "react/react-in-jsx-scope": "off",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}
```

### 11.3 Prettier 設定（推奨）

```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}
```

## 12. ベストプラクティス

### 12.1 DRY (Don't Repeat Yourself)

```typescript
// Bad: 繰り返しコード
const x1 = voxel.position[0] * SCALE;
const y1 = voxel.position[1] * SCALE;
const z1 = voxel.position[2] * SCALE;
// ... 複数回繰り返す

// Good: ユーティリティ関数に抽出
function scalePosition(position: VoxelPosition): Vector3 {
  return {
    x: position[0] * SCALE,
    y: position[1] * SCALE,
    z: position[2] * SCALE,
  };
}
```

### 12.2 SOLID 原則

```typescript
// Single Responsibility
class VoxelGridManager { /* グリッド管理のみ */ }
class VoxelRenderer { /* 描画のみ */ }
class FileHandler { /* ファイルI/Oのみ */ }

// Open/Closed for Extension
interface IVoxelEffect {
  apply(voxel: Voxel): void;
}

class HighlightEffect implements IVoxelEffect {
  apply(voxel: Voxel): void { /* ... */ }
}

// Dependency Inversion
class Editor {
  constructor(private gridManager: VoxelGridManager) {}
}
```

### 12.3 不変性 (Immutability)

```typescript
// Good: 不変性を保証
const addVoxel = (state: VoxelState, position: VoxelPosition): VoxelState => ({
  ...state,
  voxels: [...state.voxels, { id: generateId(), position }],
});

// Avoid: 直接変更
// state.voxels.push(newVoxel); // 悪い例
```

## 13. チェックリスト

実装前に確認すべき項目：

- [ ] TypeScript strict modeで型安全性を確保
- [ ] 関数の責任は単一か
- [ ] エラーハンドリングを実装しているか
- [ ] Three.jsリソースは適切に破棄されているか
- [ ] テストを作成しているか
- [ ] パフォーマンス問題はないか
- [ ] JSDocコメントを記述しているか
- [ ] コードレビュー時の指摘に対応したか
- [ ] ファイルサイズが大きくないか（300行以上は分割を検討）
- [ ] 不要なコメントは削除したか

---

**参考**: このドキュメントは Boxel Editor プロジェクトのコーディング標準として機能します。  
定期的に見直し、プロジェクト成長に合わせて更新してください。
