# 3Dオブジェクト・ボクセルメッシュ仕様書

## 1. 概要

Boxel Editorは8頂点からなるボクセル（立方体）をグリッド状に配置して、3Dモデルを構築する。このドキュメントはボクセルメッシュの構造と管理方法を定義する。

## 2. ボクセル構造

### 2.1 基本構成

**ボクセル = 8つの頂点を持つ立方体**

```
     v4 -------- v5
    /|          /|
   / |         / |
  v0 -------- v1 |
  |  v6 ------|--v7
  | /         | /
  |/          |/
  v2 -------- v3
```

### 2.2 頂点座標

ボクセルの位置が (x, y, z) の場合、8つの頂点の座標：

| 頂点ID | 座標 |
| --- | --- |
| v0 | (x, y+1, z) |
| v1 | (x+1, y+1, z) |
| v2 | (x, y, z) |
| v3 | (x+1, y, z) |
| v4 | (x, y+1, z+1) |
| v5 | (x+1, y+1, z+1) |
| v6 | (x, y, z+1) |
| v7 | (x+1, y, z+1) |

### 2.3 面（フェース）定義

各ボクセルは6つの面を持つ：

| 面ID | 名称 | 頂点順序 | 法線方向 | 
| --- | --- | --- | --- |
| 0 | 上面（Top） | v0, v1, v5, v4 | (0, 1, 0) |
| 1 | 下面（Bottom） | v2, v3, v7, v6 | (0, -1, 0) |
| 2 | 正面（Front） | v0, v1, v3, v2 | (0, 0, -1) |
| 3 | 背面（Back） | v4, v5, v7, v6 | (0, 0, 1) |
| 4 | 左面（Left） | v0, v2, v6, v4 | (-1, 0, 0) |
| 5 | 右面（Right） | v1, v3, v7, v5 | (1, 0, 0) |

### 2.4 グリッド配置

#### 2.4.1 グリッドサイズ
- **X軸**: 1～50個のボクセル
- **Y軸**: 1～50個のボクセル
- **Z軸**: 固定値（起動時に X×Y のサイズに基づいて決定される場合あり、または1固定）

#### 2.4.2 座標系

```
Y軸（上下）
^
|     Z軸（奥行き）
|    /
|   /
+--+---> X軸（左右）
```

- **原点**: (0, 0, 0) = メインオブジェクトのX-Z平面中心
- **底面**: Y = 0 に固定
- **配置**: グリッドの中心（X-Z平面）が (0, 0, 0) となるように配置
  - グリッド 32×32×32 の場合、ボクセルは (-16, 0, -16) ～ (16, 32, 16) に配置

## 3. メッシュデータ構造

### 3.1 ボクセルデータ

```typescript
interface Voxel {
  id: string;
  position: Vector3;          // グリッド座標 (x, y, z)
  vertices: Vertex[];         // 8つの頂点
  faces: Face[];             // 6つの面
  color?: Color;             // （オプション）ボクセル全体の色
}

interface Vertex {
  id: string;
  position: Vector3;         // ワールド座標
  normal?: Vector3;          // 法線（計算時に生成）
}

interface Face {
  id: string;
  vertexIds: string[];       // 4つの頂点ID（反時計回り）
  normal: Vector3;           // 面の法線
  color?: string;            // #RRGGBB形式の色
  material?: Material;       // PBRマテリアル
}
```

### 3.2 メッシュ統合

#### 3.2.1 頂点統合
- **目的**: メモリ効率化と描画最適化
- **方法**: 同一座標に複数の頂点が存在する場合、それらを1つの頂点に統合
- **時機**: メッシュ生成時とgltf出力時

#### 3.2.2 重複排除処理

```
処理前：ボクセル1とボクセル2が隣接
  ボクセル1 → 頂点v0, v1, v2, v3, v4, v5, v6, v7
  ボクセル2 → 頂点v0', v1', v2', v3', v4', v5', v6', v7'
  
  v0とv0'は同一座標 → 統合

処理後：統一された頂点リスト
  → 頂点v0（共用）, v1, v2, v3, ...
```

#### 3.2.3 内部頂点削除
- **時機**: gltf出力時
- **判定基準**: その頂点が外側に露出する面の頂点でなければ削除
- **実装方法**: BVH（Bounding Volume Hierarchy）またはレイキャスティングで判定

### 3.3 メッシュ最適化

#### 3.3.1 頂点キャッシング
- 各ボクセルの頂点は再利用可能なプールから取得
- 同一座標の頂点は同じオブジェクトを参照

#### 3.3.2 インデックスバッファ
- インデックスバッファで面を定義：
  ```
  indices = [v0, v1, v2, v0, v2, v3, ...] // 面ごと
  ```

## 4. 初期オブジェクト生成

### 4.1 生成ルール

起動時に X×Y グリッドサイズが指定された場合：

```
グリッドサイズ: X=32, Y=32

┌──────────────────────┐
│                      │
│    立方体/直方体     │ Y=32
│   (32×32ボクセル)    │
│                      │
└──────────────────────┘
         X=32
```

### 4.2 実装状況

実装では、Z軸もX軸、Y軸と同じサイズとして動的に生成：

```
グリッドサイズ入力例:
- X=32, Y=32, Z=32 → 32×32×32 のボクセル立方体

生成されるボクセル数: X × Y × Z個
```

#### 初期座標の計算

```typescript
const offsetX = -Math.floor(gridSize.x / 2);
const offsetY = 0;  // Y=0を基準（底面）
const offsetZ = -Math.floor(gridSize.z / 2);

// ボクセル位置 (x, y, z) のループ
for (let y = 0; y < gridSize.y; y++) {
  for (let x = 0; x < gridSize.x; x++) {
    for (let z = 0; z < gridSize.z; z++) {
      const position = new Vector3(
        offsetX + x,
        offsetY + y,
        offsetZ + z
      );
    }
  }
}
```

## 5. 動的編集

### 5.1 ボクセル追加

#### 5.1.1 配置制約
- ボクセルを追加できるのはメインオブジェクトのみ
- 選択した面に隣接する位置にボクセルを配置

#### 5.1.2 追加処理

```typescript
function addVoxel(selectedFace: Face): Voxel {
  const direction = getFaceNormal(selectedFace);
  const newPosition = calculateAdjacentPosition(
    selectedFace.parentVoxel.position,
    direction
  );
  
  const newVoxel = createVoxel(...newPosition);
  
  // メッシュの頂点を統合
  integrateVertices(newVoxel, existingVoxels);
  
  return newVoxel;
}
```

### 5.2 ボクセル削除

#### 5.2.1 削除処理

```typescript
function deleteVoxel(voxel: Voxel): void {
  // ボクセルを削除
  voxels = voxels.filter(v => v.id !== voxel.id);
  
  // 不要な頂点を削除（孤立頂点）
  cleanupOrphanedVertices();
  
  // メッシュを再構築
  rebuildMesh();
}
```

## 6. 隣接オブジェクトの処理

### 6.1 配置方法

隣接オブジェクトはメインオブジェクトの6方向に配置：

```
     [前]
      ▲
      │
[左]◄─┼─►[右]
      │
      ▼
     [後]
     
[上] と [下] は Y軸
```

### 6.2 位置計算

```typescript
interface AdjacencyOffset {
  direction: "up" | "down" | "left" | "right" | "front" | "back";
  offset: Vector3;
}

const adjacencyOffsets = {
  up:    { x: 0, y: mainGridY, z: 0 },
  down:  { x: 0, y: -adjacentGridY, z: 0 },
  left:  { x: -adjacentGridX, y: 0, z: 0 },
  right: { x: mainGridX, y: 0, z: 0 },
  front: { x: 0, y: 0, z: -adjacentGridZ },
  back:  { x: 0, y: 0, z: mainGridZ }
};
```

### 6.3 レンダリング

- **メインオブジェクト**: 標準レンダリング（着色対応）
- **隣接オブジェクト**: グレースケール + 半透明（70%～80%不透明度）
- **インタラクション**: 隣接オブジェクトは選択不可

## 7. パフォーマンス最適化

### 7.1 メモリ効率

**最大ボクセル数**: 50×50×Z = 最大2,500ボクセル

```
メモリ計算例（Z=1の場合）:
- 頂点数: 最大 50×50×4 = 10,000個 （共有を考慮すると約6,000個）
- 各頂点: 12bytes（float×3） = 72KB
- インデックス: 50×50×6×6bytes = 90KB
- 合計: ~200KB程度
```

### 7.2 描画最適化

- **インスタンシング**: 同一メッシュの複数配置（隣接オブジェクト）
- **LOD（Level of Detail）**: 不要（ボクセルは比較的単純）
- **フラスタム カリング**: 画面外のオブジェクトを描画から除外

### 7.3 更新処理

- **ダーティフラグ**: メッシュが変更されたかをフラグで追跡
- **遅延更新**: フレーム末尾で必要なメッシュだけ再構築
- **バッチ更新**: 複数の変更をまとめて1度にメッシュ再構築

## 8. データ永続化

メッシュデータはglw形式ファイルに以下の形式で保存：

```json
{
  "voxels": [
    {
      "id": "voxel_0",
      "position": { "x": 0, "y": 0, "z": 0 },
      "vertices": [ /* 頂点データ */ ],
      "faces": [ /* 面データ */ ]
    }
  ]
}
```

詳細は [ファイル仕様書](ファイル仕様書.md) を参照。
