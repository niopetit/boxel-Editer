# 3Dオブジェクト・ボクセルメッシュ仕様書

## 1. 概要

Boxel Editorは8頂点からなるボクセル（立方体）をグリッド状に配置して、3Dモデルを構築する。このドキュメントはボクセルメッシュの構造と管理方法を定義する。

## 2. ボクセル構造

### 2.1 基本構成

**ボクセル = 8つの頂点を持つ立方体**

```
     v4 -------- v5
    /|          /|
   / |         / |
  v0 -------- v1 |
  |  v6 ------|--v7
  | /         | /
  |/          |/
  v2 -------- v3
```

### 2.2 頂点座標

ボクセルの位置が (x, y, z) の場合、8つの頂点の座標：

| 頂点ID | 相対座標 | 説明 |
| --- | --- | --- |
| v0 | (x, y+1, z) | 左上奥 |
| v1 | (x+1, y+1, z) | 右上奥 |
| v2 | (x, y, z) | 左下奥 |
| v3 | (x+1, y, z) | 右下奥 |
| v4 | (x, y+1, z+1) | 左上手前 |
| v5 | (x+1, y+1, z+1) | 右上手前 |
| v6 | (x, y, z+1) | 左下手前 |
| v7 | (x+1, y, z+1) | 右下手前 |

**座標系**: 
- X軸: 右方向が正
- Y軸: 上方向が正
- Z軸: 奥行き（奥が正）

### 2.3 面（フェース）定義

各ボクセルは6つの面を持つ：

| 面ID | 名称 | インデックス | 法線方向 | 説明 |
| --- | --- | --- | --- | --- |
| 0 | 上面（Top） | [0, 1, 5, 4] | (0, 1, 0) / Y+ | 上向き |
| 1 | 下面（Bottom） | [2, 3, 7, 6] | (0, -1, 0) / Y- | 下向き |
| 2 | 正面（Front） | [0, 1, 3, 2] | (0, 0, -1) / Z- | 奥側 |
| 3 | 背面（Back） | [4, 5, 7, 6] | (0, 0, 1) / Z+ | 手前側 |
| 4 | 左面（Left） | [0, 2, 6, 4] | (-1, 0, 0) / X- | 左向き |
| 5 | 右面（Right） | [1, 3, 7, 5] | (1, 0, 0) / X+ | 右向き |

各面は頂点インデックスで定義される四角形（クワッド）で、法線は外向き。

### 2.4 グリッド配置

#### 2.4.1 グリッドサイズ
- **X軸**: 1～50個のボクセル
- **Y軸**: 1～50個のボクセル
- **Z軸**: 1～50個のボクセル（起動時に指定）

#### 2.4.2 座標系と原点

```
Y軸（上下）
^
|     Z軸（奥行き）
|    /
|   /
+--+---> X軸（左右）
```

- **原点**: (0, 0, 0) = メインオブジェクトの X-Z 平面中心、底面中央
- **底面**: Y = 0 に固定
- **配置範囲**: グリッドサイズが X × Y × Z の場合
  - X軸: [-⌊X/2⌋, ⌊X/2⌋) の範囲内
  - Y軸: [0, Y) の範囲内
  - Z軸: [-⌊Z/2⌋, ⌊Z/2⌋) の範囲内

#### 2.4.3 グリッド生成計算

初期オブジェクト生成時の座標計算：

```typescript
const offsetX = -Math.floor(gridSize.x / 2);
const offsetY = 0;
const offsetZ = -Math.floor(gridSize.z / 2);

for (let y = 0; y < gridSize.y; y++) {
  for (let x = 0; x < gridSize.x; x++) {
    for (let z = 0; z < gridSize.z; z++) {
      const voxelPosition = {
        x: offsetX + x,
        y: offsetY + y,
        z: offsetZ + z
      };
      createVoxel(voxelPosition);
    }
  }
}
```

**例**: グリッドサイズ 32×32×32 の場合
- offsetX = -16, offsetY = 0, offsetZ = -16
- ボクセル位置: (-16, 0, -16) から (15, 31, 15) の範囲

#### 2.4.4 グリッド範囲制限（追加配置時）

初期設定されたグリッド範囲を超えるボクセルは配置不可：

- **検査基準**: 絶対座標（ワールド座標）で判定
- **制限ルール**:
  - X軸: `minX ≤ position.x < maxX`
  - Y軸: `minY ≤ position.y < maxY`
  - Z軸: `minZ ≤ position.z < maxZ`
- **範囲外時の処理**: コンソール警告を出力し、ボクセル生成を中止

**実装例**:

```typescript
setGridBounds(
  minX: number,
  maxX: number,
  minY: number,
  maxY: number,
  minZ: number,
  maxZ: number
): void {
  // グリッド範囲を設定
  this.minX = minX;
  this.maxX = maxX;
  this.minY = minY;
  this.maxY = maxY;
  this.minZ = minZ;
  this.maxZ = maxZ;
}

addVoxel(position: Vector3): Voxel | null {
  // グリッド範囲外チェック
  if (position.x < this.minX || position.x >= this.maxX ||
      position.y < this.minY || position.y >= this.maxY ||
      position.z < this.minZ || position.z >= this.maxZ) {
    console.warn('Voxel position out of bounds:', position);
    return null;
  }
  // ... ボクセル生成
}
```

## 3. メッシュデータ構造

### 3.1 ボクセルデータ

```typescript
interface Voxel {
  id: string;
  position: Vector3;          // グリッド座標 (x, y, z)
  vertices: Vertex[];         // 8つの頂点
  faces: Face[];             // 6つの面
}

interface Vertex {
  id: string;
  x: number;
  y: number;
  z: number;
}

interface Face {
  id: string;
  vertexIds: string[];       // 4つの頂点IDの配列
  normal: string;            // 法線方向（'x+', 'x-', 'y+', 'y-', 'z+', 'z-'）
  color: string;             // #RRGGBB形式の色
}
```

### 3.2 ボクセルID管理

- **形式**: `voxel_N` （N は連番）
- **割り当て**: ボクセル作成時に自動的に増分割り当て
- **一意性**: 各ボクセルは唯一のIDを持つ

### 3.3 色管理

#### 3.3.1 色の定義

- **対象**: ボクセル面（ポリゴン単位）
- **形式**: HEX色（#RRGGBB）
- **初期色**: グレー（#808080）

#### 3.3.2 色の更新

**通常状態**:
```typescript
updateMeshColor(
  meshGroup: THREE.Group,
  voxelId: string,
  faceId: string,
  color: string,
  isSelected: boolean = false
): void {
  // isSelected = false の場合、指定色で更新
}
```

**選択状態**:
- `isSelected = true` で呼び出す
- 選択時は指定色を暗くする：`displayColor = originalColor × 0.8`
- シェーダーマテリアル（selection.vert/frag）を適用
- グリッド線も描画

#### 3.3.3 ホバー状態

- マウスホバー時も選択マテリアルを適用
- ホバー色: 青色（#0099FF）×0.8

#### 3.3.4 色の永続化

- カスタムカラーはアプリケーション終了後も保存
- ローカルストレージで実装

### 3.4 ボクセルの重複チェック

- **チェック時期**: `addVoxel()` メソッド呼び出し時
- **判定基準**: 同一座標（x, y, z）にボクセルが既に存在
- **重複時の処理**: コンソール警告を出力し、null を返す
- **デーベース**: Map<string, Voxel> で O(1) の高速検索

### 3.5 メッシュ統合
- **目的**: メモリ効率化と描画最適化
- **方法**: 同一座標に複数の頂点が存在する場合、それらを1つの頂点に統合
- **時機**: メッシュ生成時とgltf出力時

#### 3.5.1 重複排除処理

```
処理前：ボクセル1とボクセル2が隣接
  ボクセル1 → 頂点v0, v1, v2, v3, v4, v5, v6, v7
  ボクセル2 → 頂点v0', v1', v2', v3', v4', v5', v6', v7'
  
  v0とv0'は同一座標 → 統合

処理後：統一された頂点リスト
  → 頂点v0（共用）, v1, v2, v3, ...
```

#### 3.5.2 内部頂点削除
- **時機**: gltf出力時
- **判定基準**: その頂点が外側に露出する面の頂点でなければ削除
- **実装方法**: BVH（Bounding Volume Hierarchy）またはレイキャスティングで判定

### 3.6 メッシュ最適化

#### 3.6.1 頂点キャッシング
- 各ボクセルの頂点は再利用可能なプールから取得
- 同一座標の頂点は同じオブジェクトを参照

#### 3.6.2 インデックスバッファ
- インデックスバッファで面を定義：
  ```
  indices = [v0, v1, v2, v0, v2, v3, ...] // 面ごと
  ```

## 4. 初期オブジェクト生成

### 4.1 生成ルール

起動時に X × Y × Z グリッドサイズが指定された場合、その大きさの立方体/直方体をボクセルで構成して生成：

```
グリッドサイズ入力例:
  X=32, Y=32, Z=32 → 32×32×32 のボクセル立方体
  
生成されるボクセル数: X × Y × Z 個

配置イメージ（X-Z平面俯瞰、Y=0底面）:
      Z軸
      ↑
  +16 |  ■■■■■■■■■■
      |  ■■■■■■■■■■
      |  ■■■●■■■■■■  ← (0,0,0)
      |  ■■■■■■■■■■
      |  ■■■■■■■■■■
  -16 +--+--+--+--+--+--+--+--→ X軸
     -16             0            +15
```

### 4.2 初期座標計算

```typescript
// グリッド範囲計算
const offsetX = -Math.floor(gridSize.x / 2);
const offsetY = 0;              // 底面高さ
const offsetZ = -Math.floor(gridSize.z / 2);

// グリッド範囲を設定
const minX = offsetX;
const maxX = offsetX + gridSize.x;
const minY = offsetY;
const maxY = offsetY + gridSize.y;
const minZ = offsetZ;
const maxZ = offsetZ + gridSize.z;

voxelMesh.setGridBounds(minX, maxX, minY, maxY, minZ, maxZ);

// ボクセル生成ループ
for (let y = 0; y < gridSize.y; y++) {
  for (let x = 0; x < gridSize.x; x++) {
    for (let z = 0; z < gridSize.z; z++) {
      const position = {
        x: offsetX + x,
        y: offsetY + y,
        z: offsetZ + z
      };
      voxelMesh.addVoxel(position);
    }
  }
}
```

**計算例** (X=32, Y=32, Z=32):
- offsetX = -16, offsetY = 0, offsetZ = -16
- minX=-16, maxX=16, minY=0, maxY=32, minZ=-16, maxZ=16
- ボクセル位置範囲: (-16, 0, -16) ～ (15, 31, 15)

### 4.3 グリッド範囲制限の実装

`setGridBounds()` メソッドで初期設定されたグリッドサイズを保存し、その範囲外のボクセル配置を禁止：

```typescript
class VoxelMesh {
  private minX: number;
  private maxX: number;
  private minY: number;
  private maxY: number;
  private minZ: number;
  private maxZ: number;

  setGridBounds(
    minX: number,
    maxX: number,
    minY: number,
    maxY: number,
    minZ: number,
    maxZ: number
  ): void {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
    this.minZ = minZ;
    this.maxZ = maxZ;
    console.log(`Grid bounds set: X[${minX}, ${maxX}), Y[${minY}, ${maxY}), Z[${minZ}, ${maxZ})`);
  }

  addVoxel(position: Vector3): Voxel | null {
    // グリッド範囲外チェック
    if (position.x < this.minX || position.x >= this.maxX ||
        position.y < this.minY || position.y >= this.maxY ||
        position.z < this.minZ || position.z >= this.maxZ) {
      console.warn('Voxel position out of bounds:', position);
      return null;
    }
    
    // ... ボクセル重複チェックと生成
  }
}
```

**範囲制限の効果**:
- 初期設定サイズを超えるボクセルは追加不可
- 範囲外へのボクセル配置時にはコンソール警告を出力

## 5. 動的編集

### 5.1 ボクセル追加

#### 5.1.1 配置制約
- ボクセルを追加できるのはメインオブジェクトのみ
- 選択した面に隣接する位置にボクセルを配置

#### 5.1.2 追加処理

```typescript
function addVoxel(selectedFace: Face): Voxel {
  const direction = getFaceNormal(selectedFace);
  const newPosition = calculateAdjacentPosition(
    selectedFace.parentVoxel.position,
    direction
  );
  
  const newVoxel = createVoxel(...newPosition);
  
  // メッシュの頂点を統合
  integrateVertices(newVoxel, existingVoxels);
  
  return newVoxel;
}
```

### 5.2 ボクセル削除

#### 5.2.1 削除処理

```typescript
function deleteVoxel(voxel: Voxel): void {
  // ボクセルを削除
  voxels = voxels.filter(v => v.id !== voxel.id);
  
  // 不要な頂点を削除（孤立頂点）
  cleanupOrphanedVertices();
  
  // メッシュを再構築
  rebuildMesh();
}
```

## 6. 隣接オブジェクトの処理

### 6.1 配置方法

隣接オブジェクトはメインオブジェクトの6方向に配置：

```
     [前]
      ▲
      │
[左]◄─┼─►[右]
      │
      ▼
     [後]
     
[上] と [下] は Y軸
```

### 6.2 位置計算

```typescript
interface AdjacencyOffset {
  direction: "up" | "down" | "left" | "right" | "front" | "back";
  offset: Vector3;
}

const adjacencyOffsets = {
  up:    { x: 0, y: mainGridY, z: 0 },
  down:  { x: 0, y: -adjacentGridY, z: 0 },
  left:  { x: -adjacentGridX, y: 0, z: 0 },
  right: { x: mainGridX, y: 0, z: 0 },
  front: { x: 0, y: 0, z: -adjacentGridZ },
  back:  { x: 0, y: 0, z: mainGridZ }
};
```

### 6.3 レンダリング

- **メインオブジェクト**: 標準レンダリング（着色対応）
- **隣接オブジェクト**: グレースケール + 半透明（70%～80%不透明度）
- **インタラクション**: 隣接オブジェクトは選択不可

## 7. パフォーマンス最適化

### 7.1 メモリ効率

**最大ボクセル数**: 50×50×Z = 最大2,500ボクセル

```
メモリ計算例（Z=1の場合）:
- 頂点数: 最大 50×50×4 = 10,000個 （共有を考慮すると約6,000個）
- 各頂点: 12bytes（float×3） = 72KB
- インデックス: 50×50×6×6bytes = 90KB
- 合計: ~200KB程度
```

### 7.2 描画最適化

- **インスタンシング**: 同一メッシュの複数配置（隣接オブジェクト）
- **LOD（Level of Detail）**: 不要（ボクセルは比較的単純）
- **フラスタム カリング**: 画面外のオブジェクトを描画から除外

### 7.3 更新処理

- **ダーティフラグ**: メッシュが変更されたかをフラグで追跡
- **遅延更新**: フレーム末尾で必要なメッシュだけ再構築
- **バッチ更新**: 複数の変更をまとめて1度にメッシュ再構築

## 8. データ永続化

メッシュデータはglw形式ファイルに以下の形式で保存：

```json
{
  "voxels": [
    {
      "id": "voxel_0",
      "position": { "x": 0, "y": 0, "z": 0 },
      "vertices": [ /* 頂点データ */ ],
      "faces": [ /* 面データ */ ]
    }
  ]
}
```

詳細は [ファイル仕様書](ファイル仕様書.md) を参照。
