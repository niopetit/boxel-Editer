# 複数オブジェクト配置・管理仕様書

## 1. 概要

**※ 将来実装予定**

Boxel Editorは、現在はメインオブジェクト（編集対象）のみに対応しています。複数の隣接オブジェクト（編集不可）の配置・表示機能は、今後のバージョンで実装予定です。

このドキュメントは、将来実装予定の隣接オブジェクトの配置メカニズムと管理方法を定義しています。

## 2. オブジェクト構成（将来実装予定）

### 2.1 オブジェクト種別

現在の実装では、以下のオブジェクト構成で対応：

```
Boxel Editor プロジェクト
├─ Main Object（メインオブジェクト）
│  ├─ 編集対象（✅ 実装完了）
│  ├─ グリッドサイズ: X×Y×Z
│  ├─ 着色可能
│  └─ アンドゥ・リドゥ対象
│
└─ Adjacent Objects（隣接オブジェクト）
   └─ ※ 将来実装予定
```

### 2.2 隣接オブジェクトの特性（将来実装予定）

## 3. 配置メカニズム（将来実装予定）

### 3.1 配置方向（計画）

隣接オブジェクトは6方向に配置可能：

```
    [Up]
     ▲
     │
[Left] ◄─────Main─────► [Right]
     │      Object
     ▼
   [Down]

[Front] と [Back] は Z軸方向
```

| 方向 | 英名 | 軸 | オフセット |
| --- | --- | --- | --- |
| 上 | up | Y+ | (0, mainGridY, 0) |
| 下 | down | Y- | (0, -adjacentGridY, 0) |
| 左 | left | X- | (-adjacentGridX, 0, 0) |
| 右 | right | X+ | (mainGridX, 0, 0) |
| 前 | front | Z- | (0, 0, -adjacentGridZ) |
| 後 | back | Z+ | (0, 0, mainGridZ) |

### 3.2 位置計算

```typescript
interface AdjacencyConfig {
  direction: "up" | "down" | "left" | "right" | "front" | "back";
  offset: Vector3;
  contactFace: string;  // 接触する面（参照用）
}

function calculateAdjacentPosition(
  mainGridSize: { x: number; y: number; z?: number },
  adjacentGridSize: { x: number; y: number; z?: number },
  direction: string
): Vector3 {
  const adjacencyConfigs = {
    up: (m: any, a: any) => new Vector3(0, m.y, 0),
    down: (m: any, a: any) => new Vector3(0, -a.y, 0),
    left: (m: any, a: any) => new Vector3(-a.x, 0, 0),
    right: (m: any, a: any) => new Vector3(m.x, 0, 0),
    front: (m: any, a: any) => new Vector3(0, 0, -(a.z ?? 1)),
    back: (m: any, a: any) => new Vector3(0, 0, m.z ?? 1)
  };
  
  return adjacencyConfigs[direction](mainGridSize, adjacentGridSize);
}
```

### 3.3 制約条件

- **同一方向への複数配置**: 可能（複数の隣接オブジェクトを同じ方向に配置可）
- **重複配置**: 不可（同じオブジェクトを同じ方向に複数回配置不可）
- **接触検査**: 隣接オブジェクト同士の衝突検査は不要（参照用のみ）

## 4. ファイル形式と読み込み（将来実装予定）

### 4.1 隣接オブジェクトのソース（計画）

隣接オブジェクトは既存の glw形式ファイルから読み込む：

```
~/Projects/
├─ main_project.glw      ← メインオブジェクト
├─ wall_top.glw          ← 隣接オブジェクト（上）
├─ wall_left.glw         ← 隣接オブジェクト（左）
└─ wall_right.glw        ← 隣接オブジェクト（右）
```

### 4.2 配置ファイルの保存形式

プロジェクト全体の配置情報は glw形式の `adjacentObjects` フィールドに保存：

```json
{
  "metadata": { /* ... */ },
  "mainObject": { /* ... */ },
  "adjacentObjects": [
    {
      "id": "adjacent_0",
      "filePath": "./wall_top.glw",
      "direction": "up",
      "loadedAt": "2024-01-11T10:30:00Z",
      "gridSizeX": 32,
      "gridSizeY": 16,
      "voxels": [ /* ボクセルデータ */ ],
      "colors": { /* 着色情報 */ }
    },
    {
      "id": "adjacent_1",
      "filePath": "./wall_left.glw",
      "direction": "left",
      "loadedAt": "2024-01-11T10:30:05Z",
      "gridSizeX": 16,
      "gridSizeY": 32,
      "voxels": [ /* ボクセルデータ */ ],
      "colors": { /* 着色情報 */ }
    }
  ],
  "camera": { /* ... */ },
  "undoRedoHistory": [ /* ... */ ]
}
```

## 5. UI操作フロー

### 5.1 隣接オブジェクト追加フロー

```
1. ユーザーが左側パネルの「隣接オブジェクトを追加」をクリック
   ↓
2. 配置ダイアログが開く
   ↓
3. ステップ1: 配置方向を選択（ラジオボタンまたは3D立方体UI）
   ↓
4. ステップ2: ファイルブラウザで glw形式ファイルを選択
   ↓
5. 確認ボタンをクリック
   ↓
6. ファイルが読み込まれ、3D表示に隣接オブジェクトが追加される
   ↓
7. 左側パネルの「配置済み」リストに追加
```

### 5.2 隣接オブジェクト削除フロー

```
1. ユーザーが「配置済み」リストの削除ボタン（✕）をクリック
   ↓
2. 確認ダイアログが表示される（オプション）
   ↓
3. 確認後、3D表示から隣接オブジェクトが削除される
   ↓
4. リストからも削除される
   ↓
5. プロジェクトは自動保存される
```

## 6. ファイルI/O処理

### 6.1 読み込み処理

```typescript
async function loadAdjacentObject(
  filePath: string,
  direction: string
): Promise<AdjacentObject> {
  try {
    // ファイルの存在確認
    const fileExists = await fs.promises.stat(filePath);
    if (!fileExists) {
      throw new Error(`ファイルが見つかりません: ${filePath}`);
    }
    
    // ファイルの読み込み
    const fileContent = await fs.promises.readFile(filePath, "utf-8");
    const data = JSON.parse(fileContent);
    
    // バリデーション
    if (!data.mainObject || !Array.isArray(data.mainObject.voxels)) {
      throw new Error("ファイル形式が無効です");
    }
    
    // 隣接オブジェクトオブジェクトを構築
    const adjacentObject: AdjacentObject = {
      id: generateUniqueId(),
      filePath: filePath,
      direction: direction,
      gridSizeX: data.mainObject.gridSizeX,
      gridSizeY: data.mainObject.gridSizeY,
      voxels: data.mainObject.voxels,
      colors: data.mainObject.colors || {},
      loadedAt: new Date().toISOString()
    };
    
    return adjacentObject;
  } catch (error) {
    console.error("隣接オブジェクトの読み込みに失敗:", error);
    throw new Error(`隣接オブジェクトの読み込みに失敗しました: ${error.message}`);
  }
}
```

### 6.2 保存処理

```typescript
async function saveProject(
  projectPath: string,
  mainObject: MainObject,
  adjacentObjects: AdjacentObject[],
  cameraState: CameraState,
  colorPalette: ColorPalette,
  undoRedoHistory: Action[]
): Promise<void> {
  try {
    const projectData = {
      version: "1.1.0",
      metadata: {
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        gridSizeX: mainObject.gridSizeX,
        gridSizeY: mainObject.gridSizeY
      },
      mainObject: mainObject,
      adjacentObjects: adjacentObjects,
      camera: cameraState,
      colorPalette: colorPalette,
      undoRedoHistory: undoRedoHistory
    };
    
    // ファイルに保存
    await fs.promises.writeFile(
      projectPath,
      JSON.stringify(projectData, null, 2),
      "utf-8"
    );
  } catch (error) {
    console.error("プロジェクトの保存に失敗:", error);
    throw new Error("プロジェクトの保存に失敗しました");
  }
}
```

## 7. 相対パス管理

### 7.1 パス解決

隣接オブジェクトのファイルパスは相対パスで保存し、プロジェクトの移植性を確保：

```typescript
function resolveAdjacentFilePath(
  projectPath: string,
  relativePath: string
): string {
  const projectDir = path.dirname(projectPath);
  return path.resolve(projectDir, relativePath);
}

// 例:
// projectPath: /Users/user/Projects/scene.glw
// relativePath: ./objects/wall.glw
// resolvedPath: /Users/user/Projects/objects/wall.glw
```

### 7.2 パス記録

```typescript
function getRelativeFilePath(
  projectPath: string,
  adjacentFilePath: string
): string {
  const projectDir = path.dirname(projectPath);
  return path.relative(projectDir, adjacentFilePath);
}

// 例:
// projectPath: /Users/user/Projects/scene.glw
// adjacentFilePath: /Users/user/Projects/objects/wall.glw
// relativeFilePath: ./objects/wall.glw
```

## 8. レンダリング処理

### 8.1 メインオブジェクトのレンダリング

```typescript
function renderMainObject(): void {
  for (const voxel of mainObject.voxels) {
    for (const face of voxel.faces) {
      // 面の色を取得
      const color = colors.get(`${voxel.id}_${face.id}`);
      
      // マテリアルを作成
      const material = new THREE.MeshStandardMaterial({
        color: new THREE.Color(color || "#808080"),
        metalness: 0.0,
        roughness: 1.0
      });
      
      // メッシュを追加
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);
    }
  }
}
```

### 8.2 隣接オブジェクトのレンダリング

```typescript
function renderAdjacentObjects(): void {
  for (const adjacent of adjacentObjects) {
    // グレースケール化処理
    for (const voxel of adjacent.voxels) {
      for (const face of voxel.faces) {
        // デフォルトで灰色（カラー情報を無視）
        const material = new THREE.MeshStandardMaterial({
          color: new THREE.Color("#888888"),
          metalness: 0.0,
          roughness: 1.0,
          transparent: true,
          opacity: 0.75  // 75%不透明度
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
      }
    }
  }
}
```

### 8.3 インタラクション処理

```typescript
function onMouseClick(event: MouseEvent): void {
  // レイキャスティングで選択オブジェクトを判定
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2(
    (event.clientX / window.innerWidth) * 2 - 1,
    -(event.clientY / window.innerHeight) * 2 + 1
  );
  raycaster.setFromCamera(mouse, camera);
  
  const intersects = raycaster.intersectObjects(scene.children);
  
  for (const intersection of intersects) {
    const mesh = intersection.object;
    
    // メインオブジェクトか隣接オブジェクトかを判定
    if (isMainObjectMesh(mesh)) {
      handleMainObjectSelection(mesh);
    } else if (isAdjacentObjectMesh(mesh)) {
      // 隣接オブジェクトはスキップ（選択不可）
      continue;
    }
  }
}
```

## 9. メモリ管理

### 9.1 メモリサイズ計算

隣接オブジェクト1個あたりのメモリ：

```
グリッドサイズ 32×32 の隣接オブジェクト:
- ボクセルデータ: 約 100KB
- 着色情報: 約 5KB
- メタデータ: 約 5KB
合計: 約 110KB/個

最大 6個（6方向）配置した場合: 約 660KB
```

### 9.2 メモリリーク防止

```typescript
function removeAdjacentObject(adjacentId: string): void {
  // オブジェクトを配列から削除
  adjacentObjects = adjacentObjects.filter(a => a.id !== adjacentId);
  
  // Three.jsのメモリをクリア
  const meshToRemove = scene.getObjectByName(adjacentId);
  if (meshToRemove) {
    scene.remove(meshToRemove);
    meshToRemove.geometry?.dispose();
    meshToRemove.material?.dispose();
  }
}
```

## 10. エラーハンドリング

### 10.1 ファイル関連のエラー

```typescript
enum AdjacencyErrorCode {
  FILE_NOT_FOUND = "FILE_NOT_FOUND",
  INVALID_FILE_FORMAT = "INVALID_FILE_FORMAT",
  CORRUPTED_FILE = "CORRUPTED_FILE",
  PERMISSION_DENIED = "PERMISSION_DENIED",
  DISK_FULL = "DISK_FULL"
}

function handleAdjacencyError(error: AdjacencyErrorCode): void {
  const messages = {
    [AdjacencyErrorCode.FILE_NOT_FOUND]: "ファイルが見つかりません",
    [AdjacencyErrorCode.INVALID_FILE_FORMAT]: "ファイル形式が無効です",
    [AdjacencyErrorCode.CORRUPTED_FILE]: "ファイルが破損しています",
    [AdjacencyErrorCode.PERMISSION_DENIED]: "ファイルにアクセスできません",
    [AdjacencyErrorCode.DISK_FULL]: "ディスク容量が不足しています"
  };
  
  showError(messages[error]);
}
```

### 10.2 ファイルが削除された場合

プロジェクト読み込み時に隣接オブジェクトのファイルが見つからない場合：

```typescript
function validateAdjacentObjects(): void {
  for (const adjacent of adjacentObjects) {
    const filePath = resolveAdjacentFilePath(projectPath, adjacent.filePath);
    
    if (!fs.existsSync(filePath)) {
      showWarning(
        `隣接オブジェクト「${adjacent.filePath}」が見つかりません。配置から削除します。`
      );
      removeAdjacentObject(adjacent.id);
    }
  }
}
```

## 11. テスト戦略

### 11.1 単体テスト

- 隣接オブジェクトの追加・削除
- ファイル読み込み・保存
- パス解決

### 11.2 統合テスト

- メインオブジェクト + 隣接オブジェクト複数の同時表示
- レンダリングの正確性（グレースケール、透明度）
- ファイル保存・読み込み後の完全復元
- メモリリーク確認（大量追加・削除）

### 11.3 E2Eテスト

- UI上での隣接オブジェクト追加・削除フロー
- ファイル選択ダイアログの動作
- プロジェクト移動後の相対パス解決
