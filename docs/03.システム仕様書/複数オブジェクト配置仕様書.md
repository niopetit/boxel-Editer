# 複数オブジェクト配置・管理仕様書

## 1. 概要

**実装状況**: ✅ 実装完了

Boxel Editorは、メインオブジェクト（編集対象）に加え、複数の隣接オブジェクト（編集不可）を配置・表示する機能を提供する。隣接オブジェクトはGLTF/GLB形式のファイルを読み込み、元のマテリアル・テクスチャを保持したまま表示される。

## 2. オブジェクト構成

### 2.1 オブジェクト種別

```
Boxel Editor プロジェクト
├─ Main Object（メインオブジェクト）
│  ├─ 編集対象
│  ├─ グリッドサイズ: X×Y×Z
│  ├─ 着色可能
│  └─ アンドゥ・リドゥ対象
│
└─ Adjacent Objects（隣接オブジェクト）
   ├─ GLTF/GLB形式ファイルから読み込み
   ├─ 編集不可（参照用）
   ├─ 元のマテリアル・テクスチャを保持
   ├─ Y軸周りの回転が可能
   └─ 表示/非表示の切り替えが可能
```

### 2.2 隣接オブジェクトの特性

| 特性 | 内容 |
|------|------|
| 編集可否 | 編集不可（参照用） |
| 表示方式 | 元のマテリアル・テクスチャを保持 |
| 操作 | 回転（Y軸周り）、表示切替、削除 |
| ファイル形式 | GLTF (.gltf) / GLB (.glb) |

## 3. 配置メカニズム

### 3.1 配置方向

隣接オブジェクトは6方向に配置可能：

```
    [Up]
     ▲
     │
[Left] ◄─────Main─────► [Right]
     │      Object
     ▼
   [Down]

[Front] と [Back] は Z軸方向
```

| 方向 | 英名 | 軸 | オフセット計算 |
| --- | --- | --- | --- |
| 上 | up | Y+ | (0, mainGridY, 0) |
| 下 | down | Y- | (0, -adjacentGridY, 0) |
| 左 | left | X- | (-adjacentGridX, 0, 0) |
| 右 | right | X+ | (mainGridX, 0, 0) |
| 前 | front | Z- | (0, 0, -adjacentGridZ) |
| 後 | back | Z+ | (0, 0, mainGridZ) |

### 3.2 位置計算

```typescript
private calculateAdjacentPosition(
  mainGridSize: { x: number; y: number; z: number },
  adjacentGridSize: { x: number; y: number; z: number },
  direction: 'up' | 'down' | 'left' | 'right' | 'front' | 'back'
): Vector3 {
  switch (direction) {
    case 'up':
      return { x: 0, y: mainGridSize.y, z: 0 }
    case 'down':
      return { x: 0, y: -adjacentGridSize.y, z: 0 }
    case 'left':
      return { x: -adjacentGridSize.x, y: 0, z: 0 }
    case 'right':
      return { x: mainGridSize.x, y: 0, z: 0 }
    case 'front':
      return { x: 0, y: 0, z: -(adjacentGridSize.z ?? 1) }
    case 'back':
      return { x: 0, y: 0, z: mainGridSize.z ?? 1 }
    default:
      return { x: 0, y: 0, z: 0 }
  }
}
```

### 3.3 制約条件

- **同一方向への複数配置**: 可能（複数の隣接オブジェクトを同じ方向に配置可）
- **重複配置**: 不可（同じオブジェクトを同じ方向に複数回配置不可）

## 4. ファイル読み込み

### 4.1 対応ファイル形式

| 形式 | 拡張子 | 説明 |
|------|--------|------|
| glTF | .gltf | JSON形式のglTF |
| GLB | .glb | バイナリ形式のglTF |

### 4.2 読み込み処理フロー

```
1. ファイル選択ダイアログでGLTF/GLBファイルを選択
   ↓
2. Electron IPC経由でファイルをBase64として読み込み
   ↓
3. GLTFLoaderでBase64データをパース
   ↓
4. バウンディングボックスからサイズを計算
   ↓
5. 配置位置を計算
   ↓
6. メッシュグループを作成（元のマテリアルを保持）
   ↓
7. シーンに追加
```

### 4.3 IPC通信

```typescript
// メインプロセス（index.ts）
ipcMain.handle('show-gltf-open-dialog', async () => {
  const result = await dialog.showOpenDialog(mainWindow, {
    filters: [
      { name: 'glTF Files', extensions: ['gltf', 'glb'] },
      { name: 'All Files', extensions: ['*'] }
    ],
    properties: ['openFile']
  })
  return result
})

ipcMain.handle('load-gltf-file', async (_event, filePath: string) => {
  const buffer = readFileSync(filePath)
  const base64 = buffer.toString('base64')
  const extension = filePath.toLowerCase().endsWith('.glb') ? 'glb' : 'gltf'
  return { data: base64, extension, filePath }
})
```

### 4.4 GLTFパース処理

```typescript
private loadGltfFromBase64(base64Data: string, extension: string): Promise<GLTF | null> {
  return new Promise((resolve) => {
    // Base64をArrayBufferに変換
    const binaryString = atob(base64Data)
    const bytes = new Uint8Array(binaryString.length)
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i)
    }
    const arrayBuffer = bytes.buffer

    // GLTFLoaderでパース
    this.gltfLoader.parse(
      arrayBuffer,
      '',
      (gltf) => resolve(gltf),
      (error) => {
        console.error('GLTF parse error:', error)
        resolve(null)
      }
    )
  })
}
```

## 5. メッシュ生成

### 5.1 オリジナルマテリアル保持

読み込んだGLTFの元のマテリアル・テクスチャをそのまま保持して表示：

```typescript
private createOriginalMesh(scene: THREE.Object3D): THREE.Group {
  const group = new THREE.Group()
  
  scene.traverse((child) => {
    if (child instanceof THREE.Mesh) {
      // ジオメトリをクローン
      const clonedGeometry = child.geometry.clone()
      
      // ワールド変換を適用
      child.updateWorldMatrix(true, false)
      clonedGeometry.applyMatrix4(child.matrixWorld)
      
      // マテリアルをクローン（元のファイルを変更しないため）
      let clonedMaterial: THREE.Material | THREE.Material[]
      if (Array.isArray(child.material)) {
        clonedMaterial = child.material.map(m => m.clone())
      } else {
        clonedMaterial = child.material.clone()
      }
      
      // 新しいメッシュを作成
      const newMesh = new THREE.Mesh(clonedGeometry, clonedMaterial)
      newMesh.userData.isAdjacentObject = true
      
      group.add(newMesh)
    }
  })

  return group
}
```

## 6. 回転機能

### 6.1 Y軸周り回転

隣接オブジェクトをY軸周りに90度ずつ時計回りに回転：

```typescript
rotateAdjacentObjectClockwise(objectId: string): boolean {
  const obj = this.adjacentObjects.get(objectId)
  if (!obj || !obj.mesh) return false

  // Y軸周りに時計回りに90度回転（-π/2）
  obj.mesh.rotation.y -= Math.PI / 2

  return true
}
```

## 7. 表示/非表示切り替え

### 7.1 可視状態管理

```typescript
setAdjacentObjectVisibility(objectId: string, visible: boolean): boolean {
  const obj = this.adjacentObjects.get(objectId)
  if (obj) {
    obj.visible = visible
    return true
  }
  return false
}
```

### 7.2 レンダリング時の処理

```typescript
const updateAdjacentMeshes = (): void => {
  if (!adjacentMeshGroupRef.current || !adjacentObjectManagerRef.current) return

  // 既存のメッシュをクリア
  adjacentMeshGroupRef.current.clear()

  const adjacentObjs = adjacentObjectManagerRef.current.getAllAdjacentObjects()

  adjacentObjs.forEach((adjObj) => {
    // 非表示の場合はスキップ
    if (!adjObj.visible || !adjObj.mesh) return

    adjObj.mesh.position.set(adjObj.position.x, adjObj.position.y, adjObj.position.z)
    adjObj.mesh.userData.adjacentObjectId = adjObj.id
    adjacentMeshGroupRef.current?.add(adjObj.mesh)
  })
}
```

## 8. UI操作フロー

### 8.1 隣接オブジェクト追加フロー

```
1. 右パネルの「+ 隣接オブジェクトを追加」をクリック
   ↓
2. 配置ダイアログが開く
   ↓
3. 配置方向を選択（6方向ラジオボタン）
   ↓
4. 「ファイルを選択」をクリック
   ↓
5. GLTF/GLBファイルを選択
   ↓
6. ファイルが読み込まれ、3D表示に追加
   ↓
7. 右パネルの一覧に追加
```

### 8.2 隣接オブジェクト回転フロー

```
1. 右パネルの一覧から対象オブジェクトの回転ボタン（↻）をクリック
   ↓
2. Y軸周りに90度時計回りに回転
   ↓
3. 3D表示が更新
```

### 8.3 隣接オブジェクト削除フロー

```
1. 右パネルの一覧から対象オブジェクトの削除ボタン（✕）をクリック
   ↓
2. 3D表示から隣接オブジェクトが削除
   ↓
3. 一覧からも削除
```

## 9. データ構造

### 9.1 AdjacentObject インターフェース

```typescript
interface AdjacentObject {
  id: string
  filePath: string
  direction: 'up' | 'down' | 'left' | 'right' | 'front' | 'back'
  position: Vector3
  gridSizeX: number
  gridSizeY: number
  voxels: Map<string, Voxel>
  colors: Map<string, string>
  visible: boolean
}

interface AdjacentObjectWithMesh extends AdjacentObject {
  mesh: THREE.Group | null
}
```

### 9.2 AdjacentObjectManager クラス

```typescript
class AdjacentObjectManager {
  private adjacentObjects: Map<string, AdjacentObjectWithMesh>
  private objectIdCounter: number
  private gltfLoader: GLTFLoader

  // 主要メソッド
  addAdjacentObject(filePath, direction, mainGridSizeX, mainGridSizeY): Promise<AdjacentObjectWithMesh | null>
  removeAdjacentObject(objectId: string): boolean
  getAdjacentObject(objectId: string): AdjacentObject | undefined
  getAllAdjacentObjects(): AdjacentObjectWithMesh[]
  setAdjacentObjectVisibility(objectId: string, visible: boolean): boolean
  rotateAdjacentObjectClockwise(objectId: string): boolean
  dispose(): void
}
```

## 10. メモリ管理

### 10.1 リソース解放

```typescript
dispose(): void {
  this.adjacentObjects.forEach(obj => {
    obj.voxels.clear()
    obj.colors.clear()
    // メッシュのジオメトリを解放
    if (obj.mesh) {
      obj.mesh.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          child.geometry.dispose()
        }
      })
    }
  })
  this.adjacentObjects.clear()
}
```

### 10.2 個別オブジェクト削除時の解放

```typescript
removeAdjacentObject(objectId: string): boolean {
  const obj = this.adjacentObjects.get(objectId)
  if (obj) {
    // メッシュのジオメトリを解放
    if (obj.mesh) {
      obj.mesh.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          child.geometry.dispose()
        }
      })
    }
    this.adjacentObjects.delete(objectId)
    return true
  }
  return false
}
```

## 11. CSP設定

GLTFのBase64読み込みを許可するため、Content Security Policyを設定：

```html
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self' data: blob:; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self' data: blob:"
/>
```

## 12. Electron設定

GLTF読み込みを許可するため、BrowserWindowの設定：

```typescript
const window = new BrowserWindow({
  webPreferences: {
    webSecurity: false  // GLTFのdata: URI読み込みを許可
  }
})
```
